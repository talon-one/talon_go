/*
 * Talon.One API
 *
 * Use the Talon.One API to integrate with your application and to manage applications and campaigns:  - Use the operations in the [Integration API section](#integration-api) are used to integrate with our platform - Use the operation in the [Management API section](#management-api) to manage applications and campaigns.  ## Determining the base URL of the endpoints  The API is available at the same hostname as your Campaign Manager deployment. For example, if you access the Campaign Manager at `https://yourbaseurl.talon.one/`, the URL for the [updateCustomerSessionV2](https://docs.talon.one/integration-api#operation/updateCustomerSessionV2) endpoint is `https://yourbaseurl.talon.one/v2/customer_sessions/{Id}`
 *
 * API version:
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package talon

import (
	"bytes"
	"encoding/json"
	"time"
)

// NewPriceAdjustment struct for NewPriceAdjustment
type NewPriceAdjustment struct {
	// The price type (e.g. the price for members only) to apply to a given SKU.
	PriceType string `json:"priceType"`
	// The value of the price type applied to the SKU. When set to `null`, the defined price type no longer applies to the SKU.
	Price *NullableFloat32 `json:"price,omitempty"`
	// A unique reference identifier, e.g. a UUID.
	ReferenceId string `json:"referenceId"`
	// The time at which this price was calculated. If provided, this is used to determine the most recent price adjustment to choose if price adjustments overlap. Defaults to internal creation time if not provided.
	CalculatedAt *time.Time `json:"calculatedAt,omitempty"`
	// The date and time from which the price adjustment is effective.
	EffectiveFrom *time.Time `json:"effectiveFrom,omitempty"`
	// The date and time until which the price adjustment is effective.
	EffectiveUntil *time.Time `json:"effectiveUntil,omitempty"`
}

// GetPriceType returns the PriceType field value
func (o *NewPriceAdjustment) GetPriceType() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.PriceType
}

// SetPriceType sets field value
func (o *NewPriceAdjustment) SetPriceType(v string) {
	o.PriceType = v
}

// GetPrice returns the Price field value if set, zero value otherwise.
func (o *NewPriceAdjustment) GetPrice() NullableFloat32 {
	if o == nil || o.Price == nil {
		var ret NullableFloat32
		return ret
	}
	return *o.Price
}

// GetPriceOk returns a tuple with the Price field value if set, zero value otherwise
// and a boolean to check if the value has been set.
func (o *NewPriceAdjustment) GetPriceOk() (NullableFloat32, bool) {
	if o == nil || o.Price == nil {
		var ret NullableFloat32
		return ret, false
	}
	return *o.Price, true
}

// HasPrice returns a boolean if a field has been set.
func (o *NewPriceAdjustment) HasPrice() bool {
	if o != nil && o.Price != nil {
		return true
	}

	return false
}

// SetPrice gets a reference to the given NullableFloat32 and assigns it to the Price field.
func (o *NewPriceAdjustment) SetPrice(v NullableFloat32) {
	o.Price = &v
}

// GetReferenceId returns the ReferenceId field value
func (o *NewPriceAdjustment) GetReferenceId() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.ReferenceId
}

// SetReferenceId sets field value
func (o *NewPriceAdjustment) SetReferenceId(v string) {
	o.ReferenceId = v
}

// GetCalculatedAt returns the CalculatedAt field value if set, zero value otherwise.
func (o *NewPriceAdjustment) GetCalculatedAt() time.Time {
	if o == nil || o.CalculatedAt == nil {
		var ret time.Time
		return ret
	}
	return *o.CalculatedAt
}

// GetCalculatedAtOk returns a tuple with the CalculatedAt field value if set, zero value otherwise
// and a boolean to check if the value has been set.
func (o *NewPriceAdjustment) GetCalculatedAtOk() (time.Time, bool) {
	if o == nil || o.CalculatedAt == nil {
		var ret time.Time
		return ret, false
	}
	return *o.CalculatedAt, true
}

// HasCalculatedAt returns a boolean if a field has been set.
func (o *NewPriceAdjustment) HasCalculatedAt() bool {
	if o != nil && o.CalculatedAt != nil {
		return true
	}

	return false
}

// SetCalculatedAt gets a reference to the given time.Time and assigns it to the CalculatedAt field.
func (o *NewPriceAdjustment) SetCalculatedAt(v time.Time) {
	o.CalculatedAt = &v
}

// GetEffectiveFrom returns the EffectiveFrom field value if set, zero value otherwise.
func (o *NewPriceAdjustment) GetEffectiveFrom() time.Time {
	if o == nil || o.EffectiveFrom == nil {
		var ret time.Time
		return ret
	}
	return *o.EffectiveFrom
}

// GetEffectiveFromOk returns a tuple with the EffectiveFrom field value if set, zero value otherwise
// and a boolean to check if the value has been set.
func (o *NewPriceAdjustment) GetEffectiveFromOk() (time.Time, bool) {
	if o == nil || o.EffectiveFrom == nil {
		var ret time.Time
		return ret, false
	}
	return *o.EffectiveFrom, true
}

// HasEffectiveFrom returns a boolean if a field has been set.
func (o *NewPriceAdjustment) HasEffectiveFrom() bool {
	if o != nil && o.EffectiveFrom != nil {
		return true
	}

	return false
}

// SetEffectiveFrom gets a reference to the given time.Time and assigns it to the EffectiveFrom field.
func (o *NewPriceAdjustment) SetEffectiveFrom(v time.Time) {
	o.EffectiveFrom = &v
}

// GetEffectiveUntil returns the EffectiveUntil field value if set, zero value otherwise.
func (o *NewPriceAdjustment) GetEffectiveUntil() time.Time {
	if o == nil || o.EffectiveUntil == nil {
		var ret time.Time
		return ret
	}
	return *o.EffectiveUntil
}

// GetEffectiveUntilOk returns a tuple with the EffectiveUntil field value if set, zero value otherwise
// and a boolean to check if the value has been set.
func (o *NewPriceAdjustment) GetEffectiveUntilOk() (time.Time, bool) {
	if o == nil || o.EffectiveUntil == nil {
		var ret time.Time
		return ret, false
	}
	return *o.EffectiveUntil, true
}

// HasEffectiveUntil returns a boolean if a field has been set.
func (o *NewPriceAdjustment) HasEffectiveUntil() bool {
	if o != nil && o.EffectiveUntil != nil {
		return true
	}

	return false
}

// SetEffectiveUntil gets a reference to the given time.Time and assigns it to the EffectiveUntil field.
func (o *NewPriceAdjustment) SetEffectiveUntil(v time.Time) {
	o.EffectiveUntil = &v
}

type NullableNewPriceAdjustment struct {
	Value        NewPriceAdjustment
	ExplicitNull bool
}

func (v NullableNewPriceAdjustment) MarshalJSON() ([]byte, error) {
	switch {
	case v.ExplicitNull:
		return []byte("null"), nil
	default:
		return json.Marshal(v.Value)
	}
}

func (v *NullableNewPriceAdjustment) UnmarshalJSON(src []byte) error {
	if bytes.Equal(src, []byte("null")) {
		v.ExplicitNull = true
		return nil
	}

	return json.Unmarshal(src, &v.Value)
}
