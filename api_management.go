/*
 * Talon.One API
 *
 * The Talon.One API is used to manage applications and campaigns, as well as to integrate with your application. The operations in the _Integration API_ section are used to integrate with our platform, while the other operations are used to manage applications and campaigns.  ### Where is the API?  The API is available at the same hostname as these docs. For example, if you are reading this page at `https://mycompany.talon.one/docs/api/`, the URL for the [updateCustomerProfile][] operation is `https://mycompany.talon.one/v1/customer_profiles/id`  [updateCustomerProfile]: #operation--v1-customer_profiles--integrationId--put
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package talon

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"os"
	"strings"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// ManagementApiService ManagementApi service
type ManagementApiService service

type apiAddLoyaltyPointsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	programID     string
	integrationID string
	body          *LoyaltyPoints
}

func (r apiAddLoyaltyPointsRequest) Body(body LoyaltyPoints) apiAddLoyaltyPointsRequest {
	r.body = &body
	return r
}

/*
AddLoyaltyPoints Add points in a certain loyalty program for the specified customer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param programID
 * @param integrationID
@return apiAddLoyaltyPointsRequest
*/
func (a *ManagementApiService) AddLoyaltyPoints(ctx _context.Context, programID string, integrationID string) apiAddLoyaltyPointsRequest {
	return apiAddLoyaltyPointsRequest{
		apiService:    a,
		ctx:           ctx,
		programID:     programID,
		integrationID: integrationID,
	}
}

/*
Execute executes the request

*/
func (r apiAddLoyaltyPointsRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.AddLoyaltyPoints")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/loyalty_programs/{programID}/profile/{integrationID}/add_points"
	localVarPath = strings.Replace(localVarPath, "{"+"programID"+"}", _neturl.QueryEscape(parameterToString(r.programID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationID"+"}", _neturl.QueryEscape(parameterToString(r.integrationID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiCopyCampaignToApplicationsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	body          *CampaignCopy
}

func (r apiCopyCampaignToApplicationsRequest) Body(body CampaignCopy) apiCopyCampaignToApplicationsRequest {
	r.body = &body
	return r
}

/*
CopyCampaignToApplications Copy the campaign into every specified application
Copy the campaign into every specified application.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiCopyCampaignToApplicationsRequest
*/
func (a *ManagementApiService) CopyCampaignToApplications(ctx _context.Context, applicationId int32, campaignId int32) apiCopyCampaignToApplicationsRequest {
	return apiCopyCampaignToApplicationsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2002
*/
func (r apiCopyCampaignToApplicationsRequest) Execute() (InlineResponse2002, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2002
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CopyCampaignToApplications")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2002
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiCreateAdditionalCostRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	body       *NewAdditionalCost
}

func (r apiCreateAdditionalCostRequest) Body(body NewAdditionalCost) apiCreateAdditionalCostRequest {
	r.body = &body
	return r
}

/*
CreateAdditionalCost Define a new additional cost
Defines a new _additional cost_ in this account.

These additional costs are shared across all applications in your account, and are never required.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiCreateAdditionalCostRequest
*/
func (a *ManagementApiService) CreateAdditionalCost(ctx _context.Context) apiCreateAdditionalCostRequest {
	return apiCreateAdditionalCostRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return AccountAdditionalCost
*/
func (r apiCreateAdditionalCostRequest) Execute() (AccountAdditionalCost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountAdditionalCost
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CreateAdditionalCost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/additional_costs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v AccountAdditionalCost
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiCreateAttributeRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	body       *NewAttribute
}

func (r apiCreateAttributeRequest) Body(body NewAttribute) apiCreateAttributeRequest {
	r.body = &body
	return r
}

/*
CreateAttribute Define a new custom attribute
Defines a new _custom attribute_ in this account. Custom attributes allow you to attach new fields to Talon.One domain objects like campaigns, coupons, customers and so on. These attributes can then be given values when creating / updating these objects, and these values can be used in your campaign rules. For example, you could define a `zipCode` field for customer sessions, and add a rule to your campaign that only allows certain ZIP codes.

These attributes are shared across all applications in your account, and are never required.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiCreateAttributeRequest
*/
func (a *ManagementApiService) CreateAttribute(ctx _context.Context) apiCreateAttributeRequest {
	return apiCreateAttributeRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return Attribute
*/
func (r apiCreateAttributeRequest) Execute() (Attribute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Attribute
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CreateAttribute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/attributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v Attribute
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiCreateCampaignRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	body          *NewCampaign
}

func (r apiCreateCampaignRequest) Body(body NewCampaign) apiCreateCampaignRequest {
	r.body = &body
	return r
}

/*
CreateCampaign Create a Campaign
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiCreateCampaignRequest
*/
func (a *ManagementApiService) CreateCampaign(ctx _context.Context, applicationId int32) apiCreateCampaignRequest {
	return apiCreateCampaignRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return Campaign
*/
func (r apiCreateCampaignRequest) Execute() (Campaign, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Campaign
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CreateCampaign")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v Campaign
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiCreateCouponsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	body          *NewCoupons
	silent        *string
}

func (r apiCreateCouponsRequest) Body(body NewCoupons) apiCreateCouponsRequest {
	r.body = &body
	return r
}

func (r apiCreateCouponsRequest) Silent(silent string) apiCreateCouponsRequest {
	r.silent = &silent
	return r
}

/*
CreateCoupons Create Coupons
Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupons can be created.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiCreateCouponsRequest
*/
func (a *ManagementApiService) CreateCoupons(ctx _context.Context, applicationId int32, campaignId int32) apiCreateCouponsRequest {
	return apiCreateCouponsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2004
*/
func (r apiCreateCouponsRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CreateCoupons")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.silent != nil {
		localVarQueryParams.Add("silent", parameterToString(*r.silent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2004
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiCreateCouponsForMultipleRecipientsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	body          *NewCouponsForMultipleRecipients
	silent        *string
}

func (r apiCreateCouponsForMultipleRecipientsRequest) Body(body NewCouponsForMultipleRecipients) apiCreateCouponsForMultipleRecipientsRequest {
	r.body = &body
	return r
}

func (r apiCreateCouponsForMultipleRecipientsRequest) Silent(silent string) apiCreateCouponsForMultipleRecipientsRequest {
	r.silent = &silent
	return r
}

/*
CreateCouponsForMultipleRecipients Create Coupons for Multiple Recipients
Create coupons according to some pattern for up to 1000 recipients.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiCreateCouponsForMultipleRecipientsRequest
*/
func (a *ManagementApiService) CreateCouponsForMultipleRecipients(ctx _context.Context, applicationId int32, campaignId int32) apiCreateCouponsForMultipleRecipientsRequest {
	return apiCreateCouponsForMultipleRecipientsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2004
*/
func (r apiCreateCouponsForMultipleRecipientsRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CreateCouponsForMultipleRecipients")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_with_recipients"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.silent != nil {
		localVarQueryParams.Add("silent", parameterToString(*r.silent, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2004
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiCreatePasswordRecoveryEmailRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	body       *NewPasswordEmail
}

func (r apiCreatePasswordRecoveryEmailRequest) Body(body NewPasswordEmail) apiCreatePasswordRecoveryEmailRequest {
	r.body = &body
	return r
}

/*
CreatePasswordRecoveryEmail Request a password reset
Sends an email with a password recovery link to the email of an existing account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiCreatePasswordRecoveryEmailRequest
*/
func (a *ManagementApiService) CreatePasswordRecoveryEmail(ctx _context.Context) apiCreatePasswordRecoveryEmailRequest {
	return apiCreatePasswordRecoveryEmailRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return NewPasswordEmail
*/
func (r apiCreatePasswordRecoveryEmailRequest) Execute() (NewPasswordEmail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NewPasswordEmail
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CreatePasswordRecoveryEmail")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/password_recovery_emails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 204 {
			var v NewPasswordEmail
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiCreateRulesetRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	body          *NewRuleset
}

func (r apiCreateRulesetRequest) Body(body NewRuleset) apiCreateRulesetRequest {
	r.body = &body
	return r
}

/*
CreateRuleset Create a Ruleset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiCreateRulesetRequest
*/
func (a *ManagementApiService) CreateRuleset(ctx _context.Context, applicationId int32, campaignId int32) apiCreateRulesetRequest {
	return apiCreateRulesetRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return Ruleset
*/
func (r apiCreateRulesetRequest) Execute() (Ruleset, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Ruleset
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CreateRuleset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v Ruleset
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiCreateSessionRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	body       *LoginParams
}

func (r apiCreateSessionRequest) Body(body LoginParams) apiCreateSessionRequest {
	r.body = &body
	return r
}

/*
CreateSession Create a Session
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiCreateSessionRequest
*/
func (a *ManagementApiService) CreateSession(ctx _context.Context) apiCreateSessionRequest {
	return apiCreateSessionRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return Session
*/
func (r apiCreateSessionRequest) Execute() (Session, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Session
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.CreateSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 201 {
			var v Session
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiDeleteCampaignRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
}

/*
DeleteCampaign Delete a Campaign
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiDeleteCampaignRequest
*/
func (a *ManagementApiService) DeleteCampaign(ctx _context.Context, applicationId int32, campaignId int32) apiDeleteCampaignRequest {
	return apiDeleteCampaignRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request

*/
func (r apiDeleteCampaignRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.DeleteCampaign")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiDeleteCouponRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	couponId      string
}

/*
DeleteCoupon Delete one Coupon
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
 * @param couponId The ID of the coupon code to delete
@return apiDeleteCouponRequest
*/
func (a *ManagementApiService) DeleteCoupon(ctx _context.Context, applicationId int32, campaignId int32, couponId string) apiDeleteCouponRequest {
	return apiDeleteCouponRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
		couponId:      couponId,
	}
}

/*
Execute executes the request

*/
func (r apiDeleteCouponRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.DeleteCoupon")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"couponId"+"}", _neturl.QueryEscape(parameterToString(r.couponId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiDeleteCouponsRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	campaignId             int32
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	startsAfter            *time.Time
	startsBefore           *time.Time
	expiresAfter           *time.Time
	expiresBefore          *time.Time
	valid                  *string
	batchId                *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	exactMatch             *bool
}

func (r apiDeleteCouponsRequest) Value(value string) apiDeleteCouponsRequest {
	r.value = &value
	return r
}

func (r apiDeleteCouponsRequest) CreatedBefore(createdBefore time.Time) apiDeleteCouponsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiDeleteCouponsRequest) CreatedAfter(createdAfter time.Time) apiDeleteCouponsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiDeleteCouponsRequest) StartsAfter(startsAfter time.Time) apiDeleteCouponsRequest {
	r.startsAfter = &startsAfter
	return r
}

func (r apiDeleteCouponsRequest) StartsBefore(startsBefore time.Time) apiDeleteCouponsRequest {
	r.startsBefore = &startsBefore
	return r
}

func (r apiDeleteCouponsRequest) ExpiresAfter(expiresAfter time.Time) apiDeleteCouponsRequest {
	r.expiresAfter = &expiresAfter
	return r
}

func (r apiDeleteCouponsRequest) ExpiresBefore(expiresBefore time.Time) apiDeleteCouponsRequest {
	r.expiresBefore = &expiresBefore
	return r
}

func (r apiDeleteCouponsRequest) Valid(valid string) apiDeleteCouponsRequest {
	r.valid = &valid
	return r
}

func (r apiDeleteCouponsRequest) BatchId(batchId string) apiDeleteCouponsRequest {
	r.batchId = &batchId
	return r
}

func (r apiDeleteCouponsRequest) Usable(usable string) apiDeleteCouponsRequest {
	r.usable = &usable
	return r
}

func (r apiDeleteCouponsRequest) ReferralId(referralId int32) apiDeleteCouponsRequest {
	r.referralId = &referralId
	return r
}

func (r apiDeleteCouponsRequest) RecipientIntegrationId(recipientIntegrationId string) apiDeleteCouponsRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiDeleteCouponsRequest) ExactMatch(exactMatch bool) apiDeleteCouponsRequest {
	r.exactMatch = &exactMatch
	return r
}

/*
DeleteCoupons Delete Coupons
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiDeleteCouponsRequest
*/
func (a *ManagementApiService) DeleteCoupons(ctx _context.Context, applicationId int32, campaignId int32) apiDeleteCouponsRequest {
	return apiDeleteCouponsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request

*/
func (r apiDeleteCouponsRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.DeleteCoupons")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.startsAfter != nil {
		localVarQueryParams.Add("startsAfter", parameterToString(*r.startsAfter, ""))
	}
	if r.startsBefore != nil {
		localVarQueryParams.Add("startsBefore", parameterToString(*r.startsBefore, ""))
	}
	if r.expiresAfter != nil {
		localVarQueryParams.Add("expiresAfter", parameterToString(*r.expiresAfter, ""))
	}
	if r.expiresBefore != nil {
		localVarQueryParams.Add("expiresBefore", parameterToString(*r.expiresBefore, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiDeleteReferralRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	referralId    string
}

/*
DeleteReferral Delete one Referral
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
 * @param referralId The ID of the referral code to delete
@return apiDeleteReferralRequest
*/
func (a *ManagementApiService) DeleteReferral(ctx _context.Context, applicationId int32, campaignId int32, referralId string) apiDeleteReferralRequest {
	return apiDeleteReferralRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
		referralId:    referralId,
	}
}

/*
Execute executes the request

*/
func (r apiDeleteReferralRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.DeleteReferral")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/{referralId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"referralId"+"}", _neturl.QueryEscape(parameterToString(r.referralId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiDeleteRulesetRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	rulesetId     int32
}

/*
DeleteRuleset Delete a Ruleset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
 * @param rulesetId
@return apiDeleteRulesetRequest
*/
func (a *ManagementApiService) DeleteRuleset(ctx _context.Context, applicationId int32, campaignId int32, rulesetId int32) apiDeleteRulesetRequest {
	return apiDeleteRulesetRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
		rulesetId:     rulesetId,
	}
}

/*
Execute executes the request

*/
func (r apiDeleteRulesetRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.DeleteRuleset")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rulesetId"+"}", _neturl.QueryEscape(parameterToString(r.rulesetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiDestroySessionRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
}

/*
DestroySession Destroy a Session
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiDestroySessionRequest
*/
func (a *ManagementApiService) DestroySession(ctx _context.Context) apiDestroySessionRequest {
	return apiDestroySessionRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request

*/
func (r apiDestroySessionRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.DestroySession")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiExportCouponsRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	campaignId             *float32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	valid                  *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	batchId                *string
	exactMatch             *bool
	dateFormat             *string
	campaignState          *string
}

func (r apiExportCouponsRequest) CampaignId(campaignId float32) apiExportCouponsRequest {
	r.campaignId = &campaignId
	return r
}

func (r apiExportCouponsRequest) Sort(sort string) apiExportCouponsRequest {
	r.sort = &sort
	return r
}

func (r apiExportCouponsRequest) Value(value string) apiExportCouponsRequest {
	r.value = &value
	return r
}

func (r apiExportCouponsRequest) CreatedBefore(createdBefore time.Time) apiExportCouponsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiExportCouponsRequest) CreatedAfter(createdAfter time.Time) apiExportCouponsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiExportCouponsRequest) Valid(valid string) apiExportCouponsRequest {
	r.valid = &valid
	return r
}

func (r apiExportCouponsRequest) Usable(usable string) apiExportCouponsRequest {
	r.usable = &usable
	return r
}

func (r apiExportCouponsRequest) ReferralId(referralId int32) apiExportCouponsRequest {
	r.referralId = &referralId
	return r
}

func (r apiExportCouponsRequest) RecipientIntegrationId(recipientIntegrationId string) apiExportCouponsRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiExportCouponsRequest) BatchId(batchId string) apiExportCouponsRequest {
	r.batchId = &batchId
	return r
}

func (r apiExportCouponsRequest) ExactMatch(exactMatch bool) apiExportCouponsRequest {
	r.exactMatch = &exactMatch
	return r
}

func (r apiExportCouponsRequest) DateFormat(dateFormat string) apiExportCouponsRequest {
	r.dateFormat = &dateFormat
	return r
}

func (r apiExportCouponsRequest) CampaignState(campaignState string) apiExportCouponsRequest {
	r.campaignState = &campaignState
	return r
}

/*
ExportCoupons Export Coupons to a CSV file.
Download a file with the coupons that match the given attributes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiExportCouponsRequest
*/
func (a *ManagementApiService) ExportCoupons(ctx _context.Context, applicationId int32) apiExportCouponsRequest {
	return apiExportCouponsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return *os.File
*/
func (r apiExportCouponsRequest) Execute() (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.ExportCoupons")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/export_coupons"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.campaignId != nil {
		localVarQueryParams.Add("campaignId", parameterToString(*r.campaignId, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	if r.dateFormat != nil {
		localVarQueryParams.Add("dateFormat", parameterToString(*r.dateFormat, ""))
	}
	if r.campaignState != nil {
		localVarQueryParams.Add("campaignState", parameterToString(*r.campaignState, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v *os.File
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiExportCustomerSessionsRequest struct {
	ctx                  _context.Context
	apiService           *ManagementApiService
	applicationId        int32
	createdBefore        *time.Time
	createdAfter         *time.Time
	profileIntegrationId *string
	dateFormat           *string
	customerSessionState *string
}

func (r apiExportCustomerSessionsRequest) CreatedBefore(createdBefore time.Time) apiExportCustomerSessionsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiExportCustomerSessionsRequest) CreatedAfter(createdAfter time.Time) apiExportCustomerSessionsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiExportCustomerSessionsRequest) ProfileIntegrationId(profileIntegrationId string) apiExportCustomerSessionsRequest {
	r.profileIntegrationId = &profileIntegrationId
	return r
}

func (r apiExportCustomerSessionsRequest) DateFormat(dateFormat string) apiExportCustomerSessionsRequest {
	r.dateFormat = &dateFormat
	return r
}

func (r apiExportCustomerSessionsRequest) CustomerSessionState(customerSessionState string) apiExportCustomerSessionsRequest {
	r.customerSessionState = &customerSessionState
	return r
}

/*
ExportCustomerSessions Export Customer Sessions to a CSV file.
Download a file with the customer sessions that match the request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiExportCustomerSessionsRequest
*/
func (a *ManagementApiService) ExportCustomerSessions(ctx _context.Context, applicationId int32) apiExportCustomerSessionsRequest {
	return apiExportCustomerSessionsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return *os.File
*/
func (r apiExportCustomerSessionsRequest) Execute() (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.ExportCustomerSessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/export_customer_sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.profileIntegrationId != nil {
		localVarQueryParams.Add("profileIntegrationId", parameterToString(*r.profileIntegrationId, ""))
	}
	if r.dateFormat != nil {
		localVarQueryParams.Add("dateFormat", parameterToString(*r.dateFormat, ""))
	}
	if r.customerSessionState != nil {
		localVarQueryParams.Add("customerSessionState", parameterToString(*r.customerSessionState, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v *os.File
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiExportEffectsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    *float32
	createdBefore *time.Time
	createdAfter  *time.Time
	dateFormat    *string
}

func (r apiExportEffectsRequest) CampaignId(campaignId float32) apiExportEffectsRequest {
	r.campaignId = &campaignId
	return r
}

func (r apiExportEffectsRequest) CreatedBefore(createdBefore time.Time) apiExportEffectsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiExportEffectsRequest) CreatedAfter(createdAfter time.Time) apiExportEffectsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiExportEffectsRequest) DateFormat(dateFormat string) apiExportEffectsRequest {
	r.dateFormat = &dateFormat
	return r
}

/*
ExportEffects Export triggered Effects to a CSV file.
Download a file with the triggered effects that match the given attributes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiExportEffectsRequest
*/
func (a *ManagementApiService) ExportEffects(ctx _context.Context, applicationId int32) apiExportEffectsRequest {
	return apiExportEffectsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return *os.File
*/
func (r apiExportEffectsRequest) Execute() (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.ExportEffects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/export_effects"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.campaignId != nil {
		localVarQueryParams.Add("campaignId", parameterToString(*r.campaignId, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.dateFormat != nil {
		localVarQueryParams.Add("dateFormat", parameterToString(*r.dateFormat, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v *os.File
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiExportLoyaltyBalanceRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	programID  string
}

/*
ExportLoyaltyBalance Export customer loyalty balance to a CSV file
Download a file with the balance of each customer in the loyalty program
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param programID
@return apiExportLoyaltyBalanceRequest
*/
func (a *ManagementApiService) ExportLoyaltyBalance(ctx _context.Context, programID string) apiExportLoyaltyBalanceRequest {
	return apiExportLoyaltyBalanceRequest{
		apiService: a,
		ctx:        ctx,
		programID:  programID,
	}
}

/*
Execute executes the request
 @return *os.File
*/
func (r apiExportLoyaltyBalanceRequest) Execute() (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.ExportLoyaltyBalance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/loyalty_programs/{programID}/export_customer_balance"
	localVarPath = strings.Replace(localVarPath, "{"+"programID"+"}", _neturl.QueryEscape(parameterToString(r.programID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v *os.File
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAccessLogsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	rangeStart    *time.Time
	rangeEnd      *time.Time
	path          *string
	method        *string
	status        *string
	pageSize      *int32
	skip          *int32
	sort          *string
}

func (r apiGetAccessLogsRequest) RangeStart(rangeStart time.Time) apiGetAccessLogsRequest {
	r.rangeStart = &rangeStart
	return r
}

func (r apiGetAccessLogsRequest) RangeEnd(rangeEnd time.Time) apiGetAccessLogsRequest {
	r.rangeEnd = &rangeEnd
	return r
}

func (r apiGetAccessLogsRequest) Path(path string) apiGetAccessLogsRequest {
	r.path = &path
	return r
}

func (r apiGetAccessLogsRequest) Method(method string) apiGetAccessLogsRequest {
	r.method = &method
	return r
}

func (r apiGetAccessLogsRequest) Status(status string) apiGetAccessLogsRequest {
	r.status = &status
	return r
}

func (r apiGetAccessLogsRequest) PageSize(pageSize int32) apiGetAccessLogsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetAccessLogsRequest) Skip(skip int32) apiGetAccessLogsRequest {
	r.skip = &skip
	return r
}

func (r apiGetAccessLogsRequest) Sort(sort string) apiGetAccessLogsRequest {
	r.sort = &sort
	return r
}

/*
GetAccessLogs Get access logs for application (with total count)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetAccessLogsRequest
*/
func (a *ManagementApiService) GetAccessLogs(ctx _context.Context, applicationId int32) apiGetAccessLogsRequest {
	return apiGetAccessLogsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse2009
*/
func (r apiGetAccessLogsRequest) Execute() (InlineResponse2009, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2009
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAccessLogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/access_logs"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.rangeStart == nil {
		return localVarReturnValue, nil, reportError("rangeStart is required and must be specified")
	}

	if r.rangeEnd == nil {
		return localVarReturnValue, nil, reportError("rangeEnd is required and must be specified")
	}

	if r.path != nil {
		localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	}
	if r.method != nil {
		localVarQueryParams.Add("method", parameterToString(*r.method, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	localVarQueryParams.Add("rangeStart", parameterToString(*r.rangeStart, ""))
	localVarQueryParams.Add("rangeEnd", parameterToString(*r.rangeEnd, ""))
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2009
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAccessLogsWithoutTotalCountRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	rangeStart    *time.Time
	rangeEnd      *time.Time
	path          *string
	method        *string
	status        *string
	pageSize      *int32
	skip          *int32
	sort          *string
}

func (r apiGetAccessLogsWithoutTotalCountRequest) RangeStart(rangeStart time.Time) apiGetAccessLogsWithoutTotalCountRequest {
	r.rangeStart = &rangeStart
	return r
}

func (r apiGetAccessLogsWithoutTotalCountRequest) RangeEnd(rangeEnd time.Time) apiGetAccessLogsWithoutTotalCountRequest {
	r.rangeEnd = &rangeEnd
	return r
}

func (r apiGetAccessLogsWithoutTotalCountRequest) Path(path string) apiGetAccessLogsWithoutTotalCountRequest {
	r.path = &path
	return r
}

func (r apiGetAccessLogsWithoutTotalCountRequest) Method(method string) apiGetAccessLogsWithoutTotalCountRequest {
	r.method = &method
	return r
}

func (r apiGetAccessLogsWithoutTotalCountRequest) Status(status string) apiGetAccessLogsWithoutTotalCountRequest {
	r.status = &status
	return r
}

func (r apiGetAccessLogsWithoutTotalCountRequest) PageSize(pageSize int32) apiGetAccessLogsWithoutTotalCountRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetAccessLogsWithoutTotalCountRequest) Skip(skip int32) apiGetAccessLogsWithoutTotalCountRequest {
	r.skip = &skip
	return r
}

func (r apiGetAccessLogsWithoutTotalCountRequest) Sort(sort string) apiGetAccessLogsWithoutTotalCountRequest {
	r.sort = &sort
	return r
}

/*
GetAccessLogsWithoutTotalCount Get access logs for application
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetAccessLogsWithoutTotalCountRequest
*/
func (a *ManagementApiService) GetAccessLogsWithoutTotalCount(ctx _context.Context, applicationId int32) apiGetAccessLogsWithoutTotalCountRequest {
	return apiGetAccessLogsWithoutTotalCountRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse20010
*/
func (r apiGetAccessLogsWithoutTotalCountRequest) Execute() (InlineResponse20010, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20010
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAccessLogsWithoutTotalCount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/access_logs/no_total"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.rangeStart == nil {
		return localVarReturnValue, nil, reportError("rangeStart is required and must be specified")
	}

	if r.rangeEnd == nil {
		return localVarReturnValue, nil, reportError("rangeEnd is required and must be specified")
	}

	if r.path != nil {
		localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	}
	if r.method != nil {
		localVarQueryParams.Add("method", parameterToString(*r.method, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	localVarQueryParams.Add("rangeStart", parameterToString(*r.rangeStart, ""))
	localVarQueryParams.Add("rangeEnd", parameterToString(*r.rangeEnd, ""))
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20010
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAccountRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	accountId  int32
}

/*
GetAccount Get Account Details
Return the details of your companies Talon.One account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId
@return apiGetAccountRequest
*/
func (a *ManagementApiService) GetAccount(ctx _context.Context, accountId int32) apiGetAccountRequest {
	return apiGetAccountRequest{
		apiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

/*
Execute executes the request
 @return Account
*/
func (r apiGetAccountRequest) Execute() (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", _neturl.QueryEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Account
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAccountAnalyticsRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	accountId  int32
}

/*
GetAccountAnalytics Get Account Analytics
Return the analytics of your companies Talon.One account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId
@return apiGetAccountAnalyticsRequest
*/
func (a *ManagementApiService) GetAccountAnalytics(ctx _context.Context, accountId int32) apiGetAccountAnalyticsRequest {
	return apiGetAccountAnalyticsRequest{
		apiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

/*
Execute executes the request
 @return AccountAnalytics
*/
func (r apiGetAccountAnalyticsRequest) Execute() (AccountAnalytics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountAnalytics
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAccountAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/accounts/{accountId}/analytics"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", _neturl.QueryEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v AccountAnalytics
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAdditionalCostRequest struct {
	ctx              _context.Context
	apiService       *ManagementApiService
	additionalCostId int32
}

/*
GetAdditionalCost Get an additional cost
Returns additional cost for the account by its id.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param additionalCostId
@return apiGetAdditionalCostRequest
*/
func (a *ManagementApiService) GetAdditionalCost(ctx _context.Context, additionalCostId int32) apiGetAdditionalCostRequest {
	return apiGetAdditionalCostRequest{
		apiService:       a,
		ctx:              ctx,
		additionalCostId: additionalCostId,
	}
}

/*
Execute executes the request
 @return AccountAdditionalCost
*/
func (r apiGetAdditionalCostRequest) Execute() (AccountAdditionalCost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountAdditionalCost
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAdditionalCost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/additional_costs/{additionalCostId}"
	localVarPath = strings.Replace(localVarPath, "{"+"additionalCostId"+"}", _neturl.QueryEscape(parameterToString(r.additionalCostId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v AccountAdditionalCost
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAdditionalCostsRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	pageSize   *int32
	skip       *int32
	sort       *string
}

func (r apiGetAdditionalCostsRequest) PageSize(pageSize int32) apiGetAdditionalCostsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetAdditionalCostsRequest) Skip(skip int32) apiGetAdditionalCostsRequest {
	r.skip = &skip
	return r
}

func (r apiGetAdditionalCostsRequest) Sort(sort string) apiGetAdditionalCostsRequest {
	r.sort = &sort
	return r
}

/*
GetAdditionalCosts List additional costs
Returns all the defined additional costs for the account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetAdditionalCostsRequest
*/
func (a *ManagementApiService) GetAdditionalCosts(ctx _context.Context) apiGetAdditionalCostsRequest {
	return apiGetAdditionalCostsRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20022
*/
func (r apiGetAdditionalCostsRequest) Execute() (InlineResponse20022, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20022
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAdditionalCosts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/additional_costs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20022
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAllAccessLogsRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	rangeStart *time.Time
	rangeEnd   *time.Time
	path       *string
	method     *string
	status     *string
	pageSize   *int32
	skip       *int32
	sort       *string
}

func (r apiGetAllAccessLogsRequest) RangeStart(rangeStart time.Time) apiGetAllAccessLogsRequest {
	r.rangeStart = &rangeStart
	return r
}

func (r apiGetAllAccessLogsRequest) RangeEnd(rangeEnd time.Time) apiGetAllAccessLogsRequest {
	r.rangeEnd = &rangeEnd
	return r
}

func (r apiGetAllAccessLogsRequest) Path(path string) apiGetAllAccessLogsRequest {
	r.path = &path
	return r
}

func (r apiGetAllAccessLogsRequest) Method(method string) apiGetAllAccessLogsRequest {
	r.method = &method
	return r
}

func (r apiGetAllAccessLogsRequest) Status(status string) apiGetAllAccessLogsRequest {
	r.status = &status
	return r
}

func (r apiGetAllAccessLogsRequest) PageSize(pageSize int32) apiGetAllAccessLogsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetAllAccessLogsRequest) Skip(skip int32) apiGetAllAccessLogsRequest {
	r.skip = &skip
	return r
}

func (r apiGetAllAccessLogsRequest) Sort(sort string) apiGetAllAccessLogsRequest {
	r.sort = &sort
	return r
}

/*
GetAllAccessLogs Get all access logs
Fetches the access logs for the entire account. Sensitive requests (logins) are _always_ filtered from the logs.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetAllAccessLogsRequest
*/
func (a *ManagementApiService) GetAllAccessLogs(ctx _context.Context) apiGetAllAccessLogsRequest {
	return apiGetAllAccessLogsRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse2009
*/
func (r apiGetAllAccessLogsRequest) Execute() (InlineResponse2009, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2009
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAllAccessLogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/access_logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.rangeStart == nil {
		return localVarReturnValue, nil, reportError("rangeStart is required and must be specified")
	}

	if r.rangeEnd == nil {
		return localVarReturnValue, nil, reportError("rangeEnd is required and must be specified")
	}

	localVarQueryParams.Add("rangeStart", parameterToString(*r.rangeStart, ""))
	localVarQueryParams.Add("rangeEnd", parameterToString(*r.rangeEnd, ""))
	if r.path != nil {
		localVarQueryParams.Add("path", parameterToString(*r.path, ""))
	}
	if r.method != nil {
		localVarQueryParams.Add("method", parameterToString(*r.method, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2009
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAllRolesRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
}

/*
GetAllRoles Get all roles.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetAllRolesRequest
*/
func (a *ManagementApiService) GetAllRoles(ctx _context.Context) apiGetAllRolesRequest {
	return apiGetAllRolesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20030
*/
func (r apiGetAllRolesRequest) Execute() (InlineResponse20030, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20030
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAllRoles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20030
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
}

/*
GetApplication Get Application
Get the application specified by the ID.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetApplicationRequest
*/
func (a *ManagementApiService) GetApplication(ctx _context.Context, applicationId int32) apiGetApplicationRequest {
	return apiGetApplicationRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return Application
*/
func (r apiGetApplicationRequest) Execute() (Application, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Application
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplication")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Application
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationApiHealthRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
}

/*
GetApplicationApiHealth Get report of health of application API
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetApplicationApiHealthRequest
*/
func (a *ManagementApiService) GetApplicationApiHealth(ctx _context.Context, applicationId int32) apiGetApplicationApiHealthRequest {
	return apiGetApplicationApiHealthRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return ApplicationApiHealth
*/
func (r apiGetApplicationApiHealthRequest) Execute() (ApplicationApiHealth, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationApiHealth
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationApiHealth")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/health_report"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationApiHealth
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationCustomerRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	customerId    int32
}

/*
GetApplicationCustomer Get Application Customer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param customerId
@return apiGetApplicationCustomerRequest
*/
func (a *ManagementApiService) GetApplicationCustomer(ctx _context.Context, applicationId int32, customerId int32) apiGetApplicationCustomerRequest {
	return apiGetApplicationCustomerRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		customerId:    customerId,
	}
}

/*
Execute executes the request
 @return ApplicationCustomer
*/
func (r apiGetApplicationCustomerRequest) Execute() (ApplicationCustomer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationCustomer
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationCustomer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/customers/{customerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", _neturl.QueryEscape(parameterToString(r.customerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationCustomer
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationCustomersRequest struct {
	ctx                 _context.Context
	apiService          *ManagementApiService
	applicationId       int32
	integrationId       *string
	pageSize            *int32
	skip                *int32
	withTotalResultSize *bool
}

func (r apiGetApplicationCustomersRequest) IntegrationId(integrationId string) apiGetApplicationCustomersRequest {
	r.integrationId = &integrationId
	return r
}

func (r apiGetApplicationCustomersRequest) PageSize(pageSize int32) apiGetApplicationCustomersRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetApplicationCustomersRequest) Skip(skip int32) apiGetApplicationCustomersRequest {
	r.skip = &skip
	return r
}

func (r apiGetApplicationCustomersRequest) WithTotalResultSize(withTotalResultSize bool) apiGetApplicationCustomersRequest {
	r.withTotalResultSize = &withTotalResultSize
	return r
}

/*
GetApplicationCustomers List Application Customers
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetApplicationCustomersRequest
*/
func (a *ManagementApiService) GetApplicationCustomers(ctx _context.Context, applicationId int32) apiGetApplicationCustomersRequest {
	return apiGetApplicationCustomersRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse20012
*/
func (r apiGetApplicationCustomersRequest) Execute() (InlineResponse20012, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20012
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationCustomers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/customers"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.integrationId != nil {
		localVarQueryParams.Add("integrationId", parameterToString(*r.integrationId, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.withTotalResultSize != nil {
		localVarQueryParams.Add("withTotalResultSize", parameterToString(*r.withTotalResultSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20012
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationCustomersByAttributesRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	body       *ApplicationCustomerSearch
}

func (r apiGetApplicationCustomersByAttributesRequest) Body(body ApplicationCustomerSearch) apiGetApplicationCustomersByAttributesRequest {
	r.body = &body
	return r
}

/*
GetApplicationCustomersByAttributes Get a list of the customer profiles that match the given attributes (with total count)
Gets a list of all the customer profiles for the account that exactly match a set of attributes.

The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.

[Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetApplicationCustomersByAttributesRequest
*/
func (a *ManagementApiService) GetApplicationCustomersByAttributes(ctx _context.Context) apiGetApplicationCustomersByAttributesRequest {
	return apiGetApplicationCustomersByAttributesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20013
*/
func (r apiGetApplicationCustomersByAttributesRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationCustomersByAttributes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/application_customer_search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Content-Signature"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Content-Signature"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20013
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationEventTypesRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	pageSize      *int32
	skip          *int32
	sort          *string
}

func (r apiGetApplicationEventTypesRequest) PageSize(pageSize int32) apiGetApplicationEventTypesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetApplicationEventTypesRequest) Skip(skip int32) apiGetApplicationEventTypesRequest {
	r.skip = &skip
	return r
}

func (r apiGetApplicationEventTypesRequest) Sort(sort string) apiGetApplicationEventTypesRequest {
	r.sort = &sort
	return r
}

/*
GetApplicationEventTypes List Applications Event Types
Get all of the distinct values of the Event `type` property for events recorded in the application.

See also: [Track an event](/integration-api/reference/#trackEvent)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetApplicationEventTypesRequest
*/
func (a *ManagementApiService) GetApplicationEventTypes(ctx _context.Context, applicationId int32) apiGetApplicationEventTypesRequest {
	return apiGetApplicationEventTypesRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse20019
*/
func (r apiGetApplicationEventTypesRequest) Execute() (InlineResponse20019, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20019
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationEventTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/event_types"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20019
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationEventsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	pageSize      *int32
	skip          *int32
	sort          *string
	type_         *string
	createdBefore *time.Time
	createdAfter  *time.Time
	session       *string
	profile       *string
	customerName  *string
	customerEmail *string
	couponCode    *string
	referralCode  *string
	ruleQuery     *string
	campaignQuery *string
}

func (r apiGetApplicationEventsRequest) PageSize(pageSize int32) apiGetApplicationEventsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetApplicationEventsRequest) Skip(skip int32) apiGetApplicationEventsRequest {
	r.skip = &skip
	return r
}

func (r apiGetApplicationEventsRequest) Sort(sort string) apiGetApplicationEventsRequest {
	r.sort = &sort
	return r
}

func (r apiGetApplicationEventsRequest) Type_(type_ string) apiGetApplicationEventsRequest {
	r.type_ = &type_
	return r
}

func (r apiGetApplicationEventsRequest) CreatedBefore(createdBefore time.Time) apiGetApplicationEventsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetApplicationEventsRequest) CreatedAfter(createdAfter time.Time) apiGetApplicationEventsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetApplicationEventsRequest) Session(session string) apiGetApplicationEventsRequest {
	r.session = &session
	return r
}

func (r apiGetApplicationEventsRequest) Profile(profile string) apiGetApplicationEventsRequest {
	r.profile = &profile
	return r
}

func (r apiGetApplicationEventsRequest) CustomerName(customerName string) apiGetApplicationEventsRequest {
	r.customerName = &customerName
	return r
}

func (r apiGetApplicationEventsRequest) CustomerEmail(customerEmail string) apiGetApplicationEventsRequest {
	r.customerEmail = &customerEmail
	return r
}

func (r apiGetApplicationEventsRequest) CouponCode(couponCode string) apiGetApplicationEventsRequest {
	r.couponCode = &couponCode
	return r
}

func (r apiGetApplicationEventsRequest) ReferralCode(referralCode string) apiGetApplicationEventsRequest {
	r.referralCode = &referralCode
	return r
}

func (r apiGetApplicationEventsRequest) RuleQuery(ruleQuery string) apiGetApplicationEventsRequest {
	r.ruleQuery = &ruleQuery
	return r
}

func (r apiGetApplicationEventsRequest) CampaignQuery(campaignQuery string) apiGetApplicationEventsRequest {
	r.campaignQuery = &campaignQuery
	return r
}

/*
GetApplicationEvents List Applications Events (with total count)
Lists all events recorded for an application.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetApplicationEventsRequest
*/
func (a *ManagementApiService) GetApplicationEvents(ctx _context.Context, applicationId int32) apiGetApplicationEventsRequest {
	return apiGetApplicationEventsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse20017
*/
func (r apiGetApplicationEventsRequest) Execute() (InlineResponse20017, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20017
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationEvents")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.session != nil {
		localVarQueryParams.Add("session", parameterToString(*r.session, ""))
	}
	if r.profile != nil {
		localVarQueryParams.Add("profile", parameterToString(*r.profile, ""))
	}
	if r.customerName != nil {
		localVarQueryParams.Add("customerName", parameterToString(*r.customerName, ""))
	}
	if r.customerEmail != nil {
		localVarQueryParams.Add("customerEmail", parameterToString(*r.customerEmail, ""))
	}
	if r.couponCode != nil {
		localVarQueryParams.Add("couponCode", parameterToString(*r.couponCode, ""))
	}
	if r.referralCode != nil {
		localVarQueryParams.Add("referralCode", parameterToString(*r.referralCode, ""))
	}
	if r.ruleQuery != nil {
		localVarQueryParams.Add("ruleQuery", parameterToString(*r.ruleQuery, ""))
	}
	if r.campaignQuery != nil {
		localVarQueryParams.Add("campaignQuery", parameterToString(*r.campaignQuery, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20017
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationEventsWithoutTotalCountRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	pageSize      *int32
	skip          *int32
	sort          *string
	type_         *string
	createdBefore *time.Time
	createdAfter  *time.Time
	session       *string
	profile       *string
	customerName  *string
	customerEmail *string
	couponCode    *string
	referralCode  *string
	ruleQuery     *string
	campaignQuery *string
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) PageSize(pageSize int32) apiGetApplicationEventsWithoutTotalCountRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) Skip(skip int32) apiGetApplicationEventsWithoutTotalCountRequest {
	r.skip = &skip
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) Sort(sort string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.sort = &sort
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) Type_(type_ string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.type_ = &type_
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) CreatedBefore(createdBefore time.Time) apiGetApplicationEventsWithoutTotalCountRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) CreatedAfter(createdAfter time.Time) apiGetApplicationEventsWithoutTotalCountRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) Session(session string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.session = &session
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) Profile(profile string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.profile = &profile
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) CustomerName(customerName string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.customerName = &customerName
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) CustomerEmail(customerEmail string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.customerEmail = &customerEmail
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) CouponCode(couponCode string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.couponCode = &couponCode
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) ReferralCode(referralCode string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.referralCode = &referralCode
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) RuleQuery(ruleQuery string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.ruleQuery = &ruleQuery
	return r
}

func (r apiGetApplicationEventsWithoutTotalCountRequest) CampaignQuery(campaignQuery string) apiGetApplicationEventsWithoutTotalCountRequest {
	r.campaignQuery = &campaignQuery
	return r
}

/*
GetApplicationEventsWithoutTotalCount List Applications Events
Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only if there are more results.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetApplicationEventsWithoutTotalCountRequest
*/
func (a *ManagementApiService) GetApplicationEventsWithoutTotalCount(ctx _context.Context, applicationId int32) apiGetApplicationEventsWithoutTotalCountRequest {
	return apiGetApplicationEventsWithoutTotalCountRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse20018
*/
func (r apiGetApplicationEventsWithoutTotalCountRequest) Execute() (InlineResponse20018, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20018
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationEventsWithoutTotalCount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/events/no_total"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.session != nil {
		localVarQueryParams.Add("session", parameterToString(*r.session, ""))
	}
	if r.profile != nil {
		localVarQueryParams.Add("profile", parameterToString(*r.profile, ""))
	}
	if r.customerName != nil {
		localVarQueryParams.Add("customerName", parameterToString(*r.customerName, ""))
	}
	if r.customerEmail != nil {
		localVarQueryParams.Add("customerEmail", parameterToString(*r.customerEmail, ""))
	}
	if r.couponCode != nil {
		localVarQueryParams.Add("couponCode", parameterToString(*r.couponCode, ""))
	}
	if r.referralCode != nil {
		localVarQueryParams.Add("referralCode", parameterToString(*r.referralCode, ""))
	}
	if r.ruleQuery != nil {
		localVarQueryParams.Add("ruleQuery", parameterToString(*r.ruleQuery, ""))
	}
	if r.campaignQuery != nil {
		localVarQueryParams.Add("campaignQuery", parameterToString(*r.campaignQuery, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20018
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationSessionRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	sessionId     int32
}

/*
GetApplicationSession Get Application Session
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param sessionId
@return apiGetApplicationSessionRequest
*/
func (a *ManagementApiService) GetApplicationSession(ctx _context.Context, applicationId int32, sessionId int32) apiGetApplicationSessionRequest {
	return apiGetApplicationSessionRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		sessionId:     sessionId,
	}
}

/*
Execute executes the request
 @return ApplicationSession
*/
func (r apiGetApplicationSessionRequest) Execute() (ApplicationSession, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationSession
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationSession")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/sessions/{sessionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", _neturl.QueryEscape(parameterToString(r.sessionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationSession
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationSessionsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	pageSize      *int32
	skip          *int32
	sort          *string
	profile       *string
	state         *string
	createdBefore *time.Time
	createdAfter  *time.Time
	coupon        *string
	referral      *string
	integrationId *string
}

func (r apiGetApplicationSessionsRequest) PageSize(pageSize int32) apiGetApplicationSessionsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetApplicationSessionsRequest) Skip(skip int32) apiGetApplicationSessionsRequest {
	r.skip = &skip
	return r
}

func (r apiGetApplicationSessionsRequest) Sort(sort string) apiGetApplicationSessionsRequest {
	r.sort = &sort
	return r
}

func (r apiGetApplicationSessionsRequest) Profile(profile string) apiGetApplicationSessionsRequest {
	r.profile = &profile
	return r
}

func (r apiGetApplicationSessionsRequest) State(state string) apiGetApplicationSessionsRequest {
	r.state = &state
	return r
}

func (r apiGetApplicationSessionsRequest) CreatedBefore(createdBefore time.Time) apiGetApplicationSessionsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetApplicationSessionsRequest) CreatedAfter(createdAfter time.Time) apiGetApplicationSessionsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetApplicationSessionsRequest) Coupon(coupon string) apiGetApplicationSessionsRequest {
	r.coupon = &coupon
	return r
}

func (r apiGetApplicationSessionsRequest) Referral(referral string) apiGetApplicationSessionsRequest {
	r.referral = &referral
	return r
}

func (r apiGetApplicationSessionsRequest) IntegrationId(integrationId string) apiGetApplicationSessionsRequest {
	r.integrationId = &integrationId
	return r
}

/*
GetApplicationSessions List Application Sessions
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetApplicationSessionsRequest
*/
func (a *ManagementApiService) GetApplicationSessions(ctx _context.Context, applicationId int32) apiGetApplicationSessionsRequest {
	return apiGetApplicationSessionsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse20016
*/
func (r apiGetApplicationSessionsRequest) Execute() (InlineResponse20016, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20016
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplicationSessions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/sessions"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.profile != nil {
		localVarQueryParams.Add("profile", parameterToString(*r.profile, ""))
	}
	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.coupon != nil {
		localVarQueryParams.Add("coupon", parameterToString(*r.coupon, ""))
	}
	if r.referral != nil {
		localVarQueryParams.Add("referral", parameterToString(*r.referral, ""))
	}
	if r.integrationId != nil {
		localVarQueryParams.Add("integrationId", parameterToString(*r.integrationId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20016
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetApplicationsRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	pageSize   *int32
	skip       *int32
	sort       *string
}

func (r apiGetApplicationsRequest) PageSize(pageSize int32) apiGetApplicationsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetApplicationsRequest) Skip(skip int32) apiGetApplicationsRequest {
	r.skip = &skip
	return r
}

func (r apiGetApplicationsRequest) Sort(sort string) apiGetApplicationsRequest {
	r.sort = &sort
	return r
}

/*
GetApplications List Applications
List all application in the current account.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetApplicationsRequest
*/
func (a *ManagementApiService) GetApplications(ctx _context.Context) apiGetApplicationsRequest {
	return apiGetApplicationsRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse2001
*/
func (r apiGetApplicationsRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetApplications")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2001
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAttributeRequest struct {
	ctx         _context.Context
	apiService  *ManagementApiService
	attributeId int32
}

/*
GetAttribute Get a custom attribute
Returns custom attribute for the account by its id.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param attributeId
@return apiGetAttributeRequest
*/
func (a *ManagementApiService) GetAttribute(ctx _context.Context, attributeId int32) apiGetAttributeRequest {
	return apiGetAttributeRequest{
		apiService:  a,
		ctx:         ctx,
		attributeId: attributeId,
	}
}

/*
Execute executes the request
 @return Attribute
*/
func (r apiGetAttributeRequest) Execute() (Attribute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Attribute
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAttribute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/attributes/{attributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.QueryEscape(parameterToString(r.attributeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Attribute
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAttributesRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	pageSize   *int32
	skip       *int32
	sort       *string
}

func (r apiGetAttributesRequest) PageSize(pageSize int32) apiGetAttributesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetAttributesRequest) Skip(skip int32) apiGetAttributesRequest {
	r.skip = &skip
	return r
}

func (r apiGetAttributesRequest) Sort(sort string) apiGetAttributesRequest {
	r.sort = &sort
	return r
}

/*
GetAttributes List custom attributes
Returns all the defined custom attributes for the account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetAttributesRequest
*/
func (a *ManagementApiService) GetAttributes(ctx _context.Context) apiGetAttributesRequest {
	return apiGetAttributesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20021
*/
func (r apiGetAttributesRequest) Execute() (InlineResponse20021, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20021
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAttributes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/attributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20021
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetAudiencesRequest struct {
	ctx                 _context.Context
	apiService          *ManagementApiService
	pageSize            *int32
	skip                *int32
	sort                *string
	withTotalResultSize *bool
}

func (r apiGetAudiencesRequest) PageSize(pageSize int32) apiGetAudiencesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetAudiencesRequest) Skip(skip int32) apiGetAudiencesRequest {
	r.skip = &skip
	return r
}

func (r apiGetAudiencesRequest) Sort(sort string) apiGetAudiencesRequest {
	r.sort = &sort
	return r
}

func (r apiGetAudiencesRequest) WithTotalResultSize(withTotalResultSize bool) apiGetAudiencesRequest {
	r.withTotalResultSize = &withTotalResultSize
	return r
}

/*
GetAudiences Get all audiences
Get All audiences created in the account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetAudiencesRequest
*/
func (a *ManagementApiService) GetAudiences(ctx _context.Context) apiGetAudiencesRequest {
	return apiGetAudiencesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20020
*/
func (r apiGetAudiencesRequest) Execute() (InlineResponse20020, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20020
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetAudiences")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/audiences"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.withTotalResultSize != nil {
		localVarQueryParams.Add("withTotalResultSize", parameterToString(*r.withTotalResultSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20020
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCampaignRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
}

/*
GetCampaign Get a Campaign
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiGetCampaignRequest
*/
func (a *ManagementApiService) GetCampaign(ctx _context.Context, applicationId int32, campaignId int32) apiGetCampaignRequest {
	return apiGetCampaignRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return Campaign
*/
func (r apiGetCampaignRequest) Execute() (Campaign, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Campaign
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCampaign")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Campaign
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCampaignAnalyticsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	rangeStart    *time.Time
	rangeEnd      *time.Time
	granularity   *string
}

func (r apiGetCampaignAnalyticsRequest) RangeStart(rangeStart time.Time) apiGetCampaignAnalyticsRequest {
	r.rangeStart = &rangeStart
	return r
}

func (r apiGetCampaignAnalyticsRequest) RangeEnd(rangeEnd time.Time) apiGetCampaignAnalyticsRequest {
	r.rangeEnd = &rangeEnd
	return r
}

func (r apiGetCampaignAnalyticsRequest) Granularity(granularity string) apiGetCampaignAnalyticsRequest {
	r.granularity = &granularity
	return r
}

/*
GetCampaignAnalytics Get analytics of campaigns
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiGetCampaignAnalyticsRequest
*/
func (a *ManagementApiService) GetCampaignAnalytics(ctx _context.Context, applicationId int32, campaignId int32) apiGetCampaignAnalyticsRequest {
	return apiGetCampaignAnalyticsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse20011
*/
func (r apiGetCampaignAnalyticsRequest) Execute() (InlineResponse20011, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20011
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCampaignAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/analytics"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.rangeStart == nil {
		return localVarReturnValue, nil, reportError("rangeStart is required and must be specified")
	}

	if r.rangeEnd == nil {
		return localVarReturnValue, nil, reportError("rangeEnd is required and must be specified")
	}

	localVarQueryParams.Add("rangeStart", parameterToString(*r.rangeStart, ""))
	localVarQueryParams.Add("rangeEnd", parameterToString(*r.rangeEnd, ""))
	if r.granularity != nil {
		localVarQueryParams.Add("granularity", parameterToString(*r.granularity, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20011
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCampaignByAttributesRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	body          *CampaignSearch
	pageSize      *int32
	skip          *int32
	sort          *string
	campaignState *string
}

func (r apiGetCampaignByAttributesRequest) Body(body CampaignSearch) apiGetCampaignByAttributesRequest {
	r.body = &body
	return r
}

func (r apiGetCampaignByAttributesRequest) PageSize(pageSize int32) apiGetCampaignByAttributesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCampaignByAttributesRequest) Skip(skip int32) apiGetCampaignByAttributesRequest {
	r.skip = &skip
	return r
}

func (r apiGetCampaignByAttributesRequest) Sort(sort string) apiGetCampaignByAttributesRequest {
	r.sort = &sort
	return r
}

func (r apiGetCampaignByAttributesRequest) CampaignState(campaignState string) apiGetCampaignByAttributesRequest {
	r.campaignState = &campaignState
	return r
}

/*
GetCampaignByAttributes Get a list of all campaigns that match the given attributes
Gets a list of all the campaigns that exactly match a set of attributes.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetCampaignByAttributesRequest
*/
func (a *ManagementApiService) GetCampaignByAttributes(ctx _context.Context, applicationId int32) apiGetCampaignByAttributesRequest {
	return apiGetCampaignByAttributesRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse2002
*/
func (r apiGetCampaignByAttributesRequest) Execute() (InlineResponse2002, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2002
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCampaignByAttributes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns_search"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.campaignState != nil {
		localVarQueryParams.Add("campaignState", parameterToString(*r.campaignState, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2002
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCampaignsRequest struct {
	ctx             _context.Context
	apiService      *ManagementApiService
	applicationId   int32
	pageSize        *int32
	skip            *int32
	sort            *string
	campaignState   *string
	name            *string
	tags            *string
	createdBefore   *time.Time
	createdAfter    *time.Time
	campaignGroupId *int32
}

func (r apiGetCampaignsRequest) PageSize(pageSize int32) apiGetCampaignsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCampaignsRequest) Skip(skip int32) apiGetCampaignsRequest {
	r.skip = &skip
	return r
}

func (r apiGetCampaignsRequest) Sort(sort string) apiGetCampaignsRequest {
	r.sort = &sort
	return r
}

func (r apiGetCampaignsRequest) CampaignState(campaignState string) apiGetCampaignsRequest {
	r.campaignState = &campaignState
	return r
}

func (r apiGetCampaignsRequest) Name(name string) apiGetCampaignsRequest {
	r.name = &name
	return r
}

func (r apiGetCampaignsRequest) Tags(tags string) apiGetCampaignsRequest {
	r.tags = &tags
	return r
}

func (r apiGetCampaignsRequest) CreatedBefore(createdBefore time.Time) apiGetCampaignsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetCampaignsRequest) CreatedAfter(createdAfter time.Time) apiGetCampaignsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetCampaignsRequest) CampaignGroupId(campaignGroupId int32) apiGetCampaignsRequest {
	r.campaignGroupId = &campaignGroupId
	return r
}

/*
GetCampaigns List your Campaigns
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetCampaignsRequest
*/
func (a *ManagementApiService) GetCampaigns(ctx _context.Context, applicationId int32) apiGetCampaignsRequest {
	return apiGetCampaignsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse2002
*/
func (r apiGetCampaignsRequest) Execute() (InlineResponse2002, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2002
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCampaigns")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.campaignState != nil {
		localVarQueryParams.Add("campaignState", parameterToString(*r.campaignState, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.tags != nil {
		localVarQueryParams.Add("tags", parameterToString(*r.tags, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.campaignGroupId != nil {
		localVarQueryParams.Add("campaignGroupId", parameterToString(*r.campaignGroupId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2002
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetChangesRequest struct {
	ctx                 _context.Context
	apiService          *ManagementApiService
	pageSize            *int32
	skip                *int32
	sort                *string
	applicationId       *int32
	entityPath          *string
	userId              *int32
	createdBefore       *time.Time
	createdAfter        *time.Time
	withTotalResultSize *bool
	includeOld          *bool
}

func (r apiGetChangesRequest) PageSize(pageSize int32) apiGetChangesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetChangesRequest) Skip(skip int32) apiGetChangesRequest {
	r.skip = &skip
	return r
}

func (r apiGetChangesRequest) Sort(sort string) apiGetChangesRequest {
	r.sort = &sort
	return r
}

func (r apiGetChangesRequest) ApplicationId(applicationId int32) apiGetChangesRequest {
	r.applicationId = &applicationId
	return r
}

func (r apiGetChangesRequest) EntityPath(entityPath string) apiGetChangesRequest {
	r.entityPath = &entityPath
	return r
}

func (r apiGetChangesRequest) UserId(userId int32) apiGetChangesRequest {
	r.userId = &userId
	return r
}

func (r apiGetChangesRequest) CreatedBefore(createdBefore time.Time) apiGetChangesRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetChangesRequest) CreatedAfter(createdAfter time.Time) apiGetChangesRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetChangesRequest) WithTotalResultSize(withTotalResultSize bool) apiGetChangesRequest {
	r.withTotalResultSize = &withTotalResultSize
	return r
}

func (r apiGetChangesRequest) IncludeOld(includeOld bool) apiGetChangesRequest {
	r.includeOld = &includeOld
	return r
}

/*
GetChanges Get audit log for an account
Get list of changes caused by API calls for an account. Only accessible for admins.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetChangesRequest
*/
func (a *ManagementApiService) GetChanges(ctx _context.Context) apiGetChangesRequest {
	return apiGetChangesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20028
*/
func (r apiGetChangesRequest) Execute() (InlineResponse20028, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20028
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetChanges")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/changes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.applicationId != nil {
		localVarQueryParams.Add("applicationId", parameterToString(*r.applicationId, ""))
	}
	if r.entityPath != nil {
		localVarQueryParams.Add("entityPath", parameterToString(*r.entityPath, ""))
	}
	if r.userId != nil {
		localVarQueryParams.Add("userId", parameterToString(*r.userId, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.withTotalResultSize != nil {
		localVarQueryParams.Add("withTotalResultSize", parameterToString(*r.withTotalResultSize, ""))
	}
	if r.includeOld != nil {
		localVarQueryParams.Add("includeOld", parameterToString(*r.includeOld, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20028
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCouponsRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	campaignId             int32
	pageSize               *int32
	skip                   *int32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	startsAfter            *time.Time
	startsBefore           *time.Time
	expiresAfter           *time.Time
	expiresBefore          *time.Time
	valid                  *string
	batchId                *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	exactMatch             *bool
}

func (r apiGetCouponsRequest) PageSize(pageSize int32) apiGetCouponsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCouponsRequest) Skip(skip int32) apiGetCouponsRequest {
	r.skip = &skip
	return r
}

func (r apiGetCouponsRequest) Sort(sort string) apiGetCouponsRequest {
	r.sort = &sort
	return r
}

func (r apiGetCouponsRequest) Value(value string) apiGetCouponsRequest {
	r.value = &value
	return r
}

func (r apiGetCouponsRequest) CreatedBefore(createdBefore time.Time) apiGetCouponsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetCouponsRequest) CreatedAfter(createdAfter time.Time) apiGetCouponsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetCouponsRequest) StartsAfter(startsAfter time.Time) apiGetCouponsRequest {
	r.startsAfter = &startsAfter
	return r
}

func (r apiGetCouponsRequest) StartsBefore(startsBefore time.Time) apiGetCouponsRequest {
	r.startsBefore = &startsBefore
	return r
}

func (r apiGetCouponsRequest) ExpiresAfter(expiresAfter time.Time) apiGetCouponsRequest {
	r.expiresAfter = &expiresAfter
	return r
}

func (r apiGetCouponsRequest) ExpiresBefore(expiresBefore time.Time) apiGetCouponsRequest {
	r.expiresBefore = &expiresBefore
	return r
}

func (r apiGetCouponsRequest) Valid(valid string) apiGetCouponsRequest {
	r.valid = &valid
	return r
}

func (r apiGetCouponsRequest) BatchId(batchId string) apiGetCouponsRequest {
	r.batchId = &batchId
	return r
}

func (r apiGetCouponsRequest) Usable(usable string) apiGetCouponsRequest {
	r.usable = &usable
	return r
}

func (r apiGetCouponsRequest) ReferralId(referralId int32) apiGetCouponsRequest {
	r.referralId = &referralId
	return r
}

func (r apiGetCouponsRequest) RecipientIntegrationId(recipientIntegrationId string) apiGetCouponsRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiGetCouponsRequest) ExactMatch(exactMatch bool) apiGetCouponsRequest {
	r.exactMatch = &exactMatch
	return r
}

/*
GetCoupons List Coupons (with total count)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiGetCouponsRequest
*/
func (a *ManagementApiService) GetCoupons(ctx _context.Context, applicationId int32, campaignId int32) apiGetCouponsRequest {
	return apiGetCouponsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2004
*/
func (r apiGetCouponsRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCoupons")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.startsAfter != nil {
		localVarQueryParams.Add("startsAfter", parameterToString(*r.startsAfter, ""))
	}
	if r.startsBefore != nil {
		localVarQueryParams.Add("startsBefore", parameterToString(*r.startsBefore, ""))
	}
	if r.expiresAfter != nil {
		localVarQueryParams.Add("expiresAfter", parameterToString(*r.expiresAfter, ""))
	}
	if r.expiresBefore != nil {
		localVarQueryParams.Add("expiresBefore", parameterToString(*r.expiresBefore, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2004
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCouponsByAttributesRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	campaignId             int32
	body                   *CouponSearch
	pageSize               *int32
	skip                   *int32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	valid                  *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	exactMatch             *bool
	batchId                *string
}

func (r apiGetCouponsByAttributesRequest) Body(body CouponSearch) apiGetCouponsByAttributesRequest {
	r.body = &body
	return r
}

func (r apiGetCouponsByAttributesRequest) PageSize(pageSize int32) apiGetCouponsByAttributesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCouponsByAttributesRequest) Skip(skip int32) apiGetCouponsByAttributesRequest {
	r.skip = &skip
	return r
}

func (r apiGetCouponsByAttributesRequest) Sort(sort string) apiGetCouponsByAttributesRequest {
	r.sort = &sort
	return r
}

func (r apiGetCouponsByAttributesRequest) Value(value string) apiGetCouponsByAttributesRequest {
	r.value = &value
	return r
}

func (r apiGetCouponsByAttributesRequest) CreatedBefore(createdBefore time.Time) apiGetCouponsByAttributesRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetCouponsByAttributesRequest) CreatedAfter(createdAfter time.Time) apiGetCouponsByAttributesRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetCouponsByAttributesRequest) Valid(valid string) apiGetCouponsByAttributesRequest {
	r.valid = &valid
	return r
}

func (r apiGetCouponsByAttributesRequest) Usable(usable string) apiGetCouponsByAttributesRequest {
	r.usable = &usable
	return r
}

func (r apiGetCouponsByAttributesRequest) ReferralId(referralId int32) apiGetCouponsByAttributesRequest {
	r.referralId = &referralId
	return r
}

func (r apiGetCouponsByAttributesRequest) RecipientIntegrationId(recipientIntegrationId string) apiGetCouponsByAttributesRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiGetCouponsByAttributesRequest) ExactMatch(exactMatch bool) apiGetCouponsByAttributesRequest {
	r.exactMatch = &exactMatch
	return r
}

func (r apiGetCouponsByAttributesRequest) BatchId(batchId string) apiGetCouponsByAttributesRequest {
	r.batchId = &batchId
	return r
}

/*
GetCouponsByAttributes Get a list of the coupons that match the given attributes
Gets a list of all the coupons that exactly match a set of attributes.

The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiGetCouponsByAttributesRequest
*/
func (a *ManagementApiService) GetCouponsByAttributes(ctx _context.Context, applicationId int32, campaignId int32) apiGetCouponsByAttributesRequest {
	return apiGetCouponsByAttributesRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2004
*/
func (r apiGetCouponsByAttributesRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCouponsByAttributes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2004
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCouponsByAttributesApplicationWideRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	body                   *CouponSearch
	pageSize               *int32
	skip                   *int32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	valid                  *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	batchId                *string
	exactMatch             *bool
	campaignState          *string
}

func (r apiGetCouponsByAttributesApplicationWideRequest) Body(body CouponSearch) apiGetCouponsByAttributesApplicationWideRequest {
	r.body = &body
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) PageSize(pageSize int32) apiGetCouponsByAttributesApplicationWideRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) Skip(skip int32) apiGetCouponsByAttributesApplicationWideRequest {
	r.skip = &skip
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) Sort(sort string) apiGetCouponsByAttributesApplicationWideRequest {
	r.sort = &sort
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) Value(value string) apiGetCouponsByAttributesApplicationWideRequest {
	r.value = &value
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) CreatedBefore(createdBefore time.Time) apiGetCouponsByAttributesApplicationWideRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) CreatedAfter(createdAfter time.Time) apiGetCouponsByAttributesApplicationWideRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) Valid(valid string) apiGetCouponsByAttributesApplicationWideRequest {
	r.valid = &valid
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) Usable(usable string) apiGetCouponsByAttributesApplicationWideRequest {
	r.usable = &usable
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) ReferralId(referralId int32) apiGetCouponsByAttributesApplicationWideRequest {
	r.referralId = &referralId
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) RecipientIntegrationId(recipientIntegrationId string) apiGetCouponsByAttributesApplicationWideRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) BatchId(batchId string) apiGetCouponsByAttributesApplicationWideRequest {
	r.batchId = &batchId
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) ExactMatch(exactMatch bool) apiGetCouponsByAttributesApplicationWideRequest {
	r.exactMatch = &exactMatch
	return r
}

func (r apiGetCouponsByAttributesApplicationWideRequest) CampaignState(campaignState string) apiGetCouponsByAttributesApplicationWideRequest {
	r.campaignState = &campaignState
	return r
}

/*
GetCouponsByAttributesApplicationWide Get a list of the coupons that match the given attributes in all active campaigns of an application (with total count)
Gets a list of all the coupons with attributes matching the query criteria Application wide

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetCouponsByAttributesApplicationWideRequest
*/
func (a *ManagementApiService) GetCouponsByAttributesApplicationWide(ctx _context.Context, applicationId int32) apiGetCouponsByAttributesApplicationWideRequest {
	return apiGetCouponsByAttributesApplicationWideRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse2004
*/
func (r apiGetCouponsByAttributesApplicationWideRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCouponsByAttributesApplicationWide")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/coupons_search"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	if r.campaignState != nil {
		localVarQueryParams.Add("campaignState", parameterToString(*r.campaignState, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2004
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCouponsWithoutTotalCountRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	campaignId             int32
	pageSize               *int32
	skip                   *int32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	valid                  *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	batchId                *string
	exactMatch             *bool
}

func (r apiGetCouponsWithoutTotalCountRequest) PageSize(pageSize int32) apiGetCouponsWithoutTotalCountRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) Skip(skip int32) apiGetCouponsWithoutTotalCountRequest {
	r.skip = &skip
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) Sort(sort string) apiGetCouponsWithoutTotalCountRequest {
	r.sort = &sort
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) Value(value string) apiGetCouponsWithoutTotalCountRequest {
	r.value = &value
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) CreatedBefore(createdBefore time.Time) apiGetCouponsWithoutTotalCountRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) CreatedAfter(createdAfter time.Time) apiGetCouponsWithoutTotalCountRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) Valid(valid string) apiGetCouponsWithoutTotalCountRequest {
	r.valid = &valid
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) Usable(usable string) apiGetCouponsWithoutTotalCountRequest {
	r.usable = &usable
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) ReferralId(referralId int32) apiGetCouponsWithoutTotalCountRequest {
	r.referralId = &referralId
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) RecipientIntegrationId(recipientIntegrationId string) apiGetCouponsWithoutTotalCountRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) BatchId(batchId string) apiGetCouponsWithoutTotalCountRequest {
	r.batchId = &batchId
	return r
}

func (r apiGetCouponsWithoutTotalCountRequest) ExactMatch(exactMatch bool) apiGetCouponsWithoutTotalCountRequest {
	r.exactMatch = &exactMatch
	return r
}

/*
GetCouponsWithoutTotalCount List Coupons
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiGetCouponsWithoutTotalCountRequest
*/
func (a *ManagementApiService) GetCouponsWithoutTotalCount(ctx _context.Context, applicationId int32, campaignId int32) apiGetCouponsWithoutTotalCountRequest {
	return apiGetCouponsWithoutTotalCountRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2005
*/
func (r apiGetCouponsWithoutTotalCountRequest) Execute() (InlineResponse2005, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2005
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCouponsWithoutTotalCount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/no_total"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCustomerActivityReportRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	rangeStart    *time.Time
	rangeEnd      *time.Time
	applicationId int32
	customerId    int32
	pageSize      *int32
	skip          *int32
}

func (r apiGetCustomerActivityReportRequest) RangeStart(rangeStart time.Time) apiGetCustomerActivityReportRequest {
	r.rangeStart = &rangeStart
	return r
}

func (r apiGetCustomerActivityReportRequest) RangeEnd(rangeEnd time.Time) apiGetCustomerActivityReportRequest {
	r.rangeEnd = &rangeEnd
	return r
}

func (r apiGetCustomerActivityReportRequest) PageSize(pageSize int32) apiGetCustomerActivityReportRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCustomerActivityReportRequest) Skip(skip int32) apiGetCustomerActivityReportRequest {
	r.skip = &skip
	return r
}

/*
GetCustomerActivityReport Get Activity Report for Single Customer
Fetch summary report for single application customer based on a time range
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param customerId
@return apiGetCustomerActivityReportRequest
*/
func (a *ManagementApiService) GetCustomerActivityReport(ctx _context.Context, applicationId int32, customerId int32) apiGetCustomerActivityReportRequest {
	return apiGetCustomerActivityReportRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		customerId:    customerId,
	}
}

/*
Execute executes the request
 @return CustomerActivityReport
*/
func (r apiGetCustomerActivityReportRequest) Execute() (CustomerActivityReport, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CustomerActivityReport
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCustomerActivityReport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/customer_activity_reports/{customerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", _neturl.QueryEscape(parameterToString(r.customerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.rangeStart == nil {
		return localVarReturnValue, nil, reportError("rangeStart is required and must be specified")
	}

	if r.rangeEnd == nil {
		return localVarReturnValue, nil, reportError("rangeEnd is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	localVarQueryParams.Add("rangeStart", parameterToString(*r.rangeStart, ""))
	localVarQueryParams.Add("rangeEnd", parameterToString(*r.rangeEnd, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v CustomerActivityReport
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCustomerActivityReportsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	rangeStart    *time.Time
	rangeEnd      *time.Time
	applicationId int32
	pageSize      *int32
	skip          *int32
	sort          *string
	name          *string
	integrationId *string
	campaignName  *string
	advocateName  *string
}

func (r apiGetCustomerActivityReportsRequest) RangeStart(rangeStart time.Time) apiGetCustomerActivityReportsRequest {
	r.rangeStart = &rangeStart
	return r
}

func (r apiGetCustomerActivityReportsRequest) RangeEnd(rangeEnd time.Time) apiGetCustomerActivityReportsRequest {
	r.rangeEnd = &rangeEnd
	return r
}

func (r apiGetCustomerActivityReportsRequest) PageSize(pageSize int32) apiGetCustomerActivityReportsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCustomerActivityReportsRequest) Skip(skip int32) apiGetCustomerActivityReportsRequest {
	r.skip = &skip
	return r
}

func (r apiGetCustomerActivityReportsRequest) Sort(sort string) apiGetCustomerActivityReportsRequest {
	r.sort = &sort
	return r
}

func (r apiGetCustomerActivityReportsRequest) Name(name string) apiGetCustomerActivityReportsRequest {
	r.name = &name
	return r
}

func (r apiGetCustomerActivityReportsRequest) IntegrationId(integrationId string) apiGetCustomerActivityReportsRequest {
	r.integrationId = &integrationId
	return r
}

func (r apiGetCustomerActivityReportsRequest) CampaignName(campaignName string) apiGetCustomerActivityReportsRequest {
	r.campaignName = &campaignName
	return r
}

func (r apiGetCustomerActivityReportsRequest) AdvocateName(advocateName string) apiGetCustomerActivityReportsRequest {
	r.advocateName = &advocateName
	return r
}

/*
GetCustomerActivityReports Get Activity Reports for Application Customers (with total count)
Fetch summary reports for all application customers based on a time range
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetCustomerActivityReportsRequest
*/
func (a *ManagementApiService) GetCustomerActivityReports(ctx _context.Context, applicationId int32) apiGetCustomerActivityReportsRequest {
	return apiGetCustomerActivityReportsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse20014
*/
func (r apiGetCustomerActivityReportsRequest) Execute() (InlineResponse20014, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20014
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCustomerActivityReports")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/customer_activity_reports"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.rangeStart == nil {
		return localVarReturnValue, nil, reportError("rangeStart is required and must be specified")
	}

	if r.rangeEnd == nil {
		return localVarReturnValue, nil, reportError("rangeEnd is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	localVarQueryParams.Add("rangeStart", parameterToString(*r.rangeStart, ""))
	localVarQueryParams.Add("rangeEnd", parameterToString(*r.rangeEnd, ""))
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.integrationId != nil {
		localVarQueryParams.Add("integrationId", parameterToString(*r.integrationId, ""))
	}
	if r.campaignName != nil {
		localVarQueryParams.Add("campaignName", parameterToString(*r.campaignName, ""))
	}
	if r.advocateName != nil {
		localVarQueryParams.Add("advocateName", parameterToString(*r.advocateName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20014
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCustomerActivityReportsWithoutTotalCountRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	rangeStart    *time.Time
	rangeEnd      *time.Time
	applicationId int32
	pageSize      *int32
	skip          *int32
	sort          *string
	name          *string
	integrationId *string
	campaignName  *string
	advocateName  *string
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) RangeStart(rangeStart time.Time) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.rangeStart = &rangeStart
	return r
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) RangeEnd(rangeEnd time.Time) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.rangeEnd = &rangeEnd
	return r
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) PageSize(pageSize int32) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) Skip(skip int32) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.skip = &skip
	return r
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) Sort(sort string) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.sort = &sort
	return r
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) Name(name string) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.name = &name
	return r
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) IntegrationId(integrationId string) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.integrationId = &integrationId
	return r
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) CampaignName(campaignName string) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.campaignName = &campaignName
	return r
}

func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) AdvocateName(advocateName string) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	r.advocateName = &advocateName
	return r
}

/*
GetCustomerActivityReportsWithoutTotalCount Get Activity Reports for Application Customers
Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only if there are more results.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiGetCustomerActivityReportsWithoutTotalCountRequest
*/
func (a *ManagementApiService) GetCustomerActivityReportsWithoutTotalCount(ctx _context.Context, applicationId int32) apiGetCustomerActivityReportsWithoutTotalCountRequest {
	return apiGetCustomerActivityReportsWithoutTotalCountRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse20015
*/
func (r apiGetCustomerActivityReportsWithoutTotalCountRequest) Execute() (InlineResponse20015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20015
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCustomerActivityReportsWithoutTotalCount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/customer_activity_reports/no_total"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.rangeStart == nil {
		return localVarReturnValue, nil, reportError("rangeStart is required and must be specified")
	}

	if r.rangeEnd == nil {
		return localVarReturnValue, nil, reportError("rangeEnd is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	localVarQueryParams.Add("rangeStart", parameterToString(*r.rangeStart, ""))
	localVarQueryParams.Add("rangeEnd", parameterToString(*r.rangeEnd, ""))
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.integrationId != nil {
		localVarQueryParams.Add("integrationId", parameterToString(*r.integrationId, ""))
	}
	if r.campaignName != nil {
		localVarQueryParams.Add("campaignName", parameterToString(*r.campaignName, ""))
	}
	if r.advocateName != nil {
		localVarQueryParams.Add("advocateName", parameterToString(*r.advocateName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20015
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCustomerAnalyticsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	customerId    int32
	pageSize      *int32
	skip          *int32
	sort          *string
}

func (r apiGetCustomerAnalyticsRequest) PageSize(pageSize int32) apiGetCustomerAnalyticsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCustomerAnalyticsRequest) Skip(skip int32) apiGetCustomerAnalyticsRequest {
	r.skip = &skip
	return r
}

func (r apiGetCustomerAnalyticsRequest) Sort(sort string) apiGetCustomerAnalyticsRequest {
	r.sort = &sort
	return r
}

/*
GetCustomerAnalytics Get Analytics Report for a Customer
Fetch analytics for single application customer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param customerId
@return apiGetCustomerAnalyticsRequest
*/
func (a *ManagementApiService) GetCustomerAnalytics(ctx _context.Context, applicationId int32, customerId int32) apiGetCustomerAnalyticsRequest {
	return apiGetCustomerAnalyticsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		customerId:    customerId,
	}
}

/*
Execute executes the request
 @return CustomerAnalytics
*/
func (r apiGetCustomerAnalyticsRequest) Execute() (CustomerAnalytics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CustomerAnalytics
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCustomerAnalytics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/customers/{customerId}/analytics"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", _neturl.QueryEscape(parameterToString(r.customerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v CustomerAnalytics
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCustomerProfileRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	customerId int32
}

/*
GetCustomerProfile Get Customer Profile
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param customerId
@return apiGetCustomerProfileRequest
*/
func (a *ManagementApiService) GetCustomerProfile(ctx _context.Context, customerId int32) apiGetCustomerProfileRequest {
	return apiGetCustomerProfileRequest{
		apiService: a,
		ctx:        ctx,
		customerId: customerId,
	}
}

/*
Execute executes the request
 @return ApplicationCustomer
*/
func (r apiGetCustomerProfileRequest) Execute() (ApplicationCustomer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ApplicationCustomer
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCustomerProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/customers/{customerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"customerId"+"}", _neturl.QueryEscape(parameterToString(r.customerId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v ApplicationCustomer
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCustomerProfilesRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	pageSize   *int32
	skip       *int32
}

func (r apiGetCustomerProfilesRequest) PageSize(pageSize int32) apiGetCustomerProfilesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCustomerProfilesRequest) Skip(skip int32) apiGetCustomerProfilesRequest {
	r.skip = &skip
	return r
}

/*
GetCustomerProfiles List Customer Profiles
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetCustomerProfilesRequest
*/
func (a *ManagementApiService) GetCustomerProfiles(ctx _context.Context) apiGetCustomerProfilesRequest {
	return apiGetCustomerProfilesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20013
*/
func (r apiGetCustomerProfilesRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCustomerProfiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/customers/no_total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20013
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetCustomersByAttributesRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	body       *ApplicationCustomerSearch
	pageSize   *int32
	skip       *int32
}

func (r apiGetCustomersByAttributesRequest) Body(body ApplicationCustomerSearch) apiGetCustomersByAttributesRequest {
	r.body = &body
	return r
}

func (r apiGetCustomersByAttributesRequest) PageSize(pageSize int32) apiGetCustomersByAttributesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetCustomersByAttributesRequest) Skip(skip int32) apiGetCustomersByAttributesRequest {
	r.skip = &skip
	return r
}

/*
GetCustomersByAttributes Get a list of the customer profiles that match the given attributes
Gets a list of all the customer profiles for the account that exactly match a set of attributes.

The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.

[Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetCustomersByAttributesRequest
*/
func (a *ManagementApiService) GetCustomersByAttributes(ctx _context.Context) apiGetCustomersByAttributesRequest {
	return apiGetCustomersByAttributesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20013
*/
func (r apiGetCustomersByAttributesRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetCustomersByAttributes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/customer_search/no_total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20013
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetEventTypesRequest struct {
	ctx                _context.Context
	apiService         *ManagementApiService
	applicationIds     *string
	name               *string
	includeOldVersions *bool
	pageSize           *int32
	skip               *int32
	sort               *string
}

func (r apiGetEventTypesRequest) ApplicationIds(applicationIds string) apiGetEventTypesRequest {
	r.applicationIds = &applicationIds
	return r
}

func (r apiGetEventTypesRequest) Name(name string) apiGetEventTypesRequest {
	r.name = &name
	return r
}

func (r apiGetEventTypesRequest) IncludeOldVersions(includeOldVersions bool) apiGetEventTypesRequest {
	r.includeOldVersions = &includeOldVersions
	return r
}

func (r apiGetEventTypesRequest) PageSize(pageSize int32) apiGetEventTypesRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetEventTypesRequest) Skip(skip int32) apiGetEventTypesRequest {
	r.skip = &skip
	return r
}

func (r apiGetEventTypesRequest) Sort(sort string) apiGetEventTypesRequest {
	r.sort = &sort
	return r
}

/*
GetEventTypes List Event Types
Fetch all event type definitions for your account. Each event type can be

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetEventTypesRequest
*/
func (a *ManagementApiService) GetEventTypes(ctx _context.Context) apiGetEventTypesRequest {
	return apiGetEventTypesRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20026
*/
func (r apiGetEventTypesRequest) Execute() (InlineResponse20026, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20026
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetEventTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/event_types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.applicationIds != nil {
		localVarQueryParams.Add("applicationIds", parameterToString(*r.applicationIds, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.includeOldVersions != nil {
		localVarQueryParams.Add("includeOldVersions", parameterToString(*r.includeOldVersions, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20026
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetExportsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	pageSize      *int32
	skip          *int32
	applicationId *int32
	campaignId    *int32
	entity        *string
}

func (r apiGetExportsRequest) PageSize(pageSize int32) apiGetExportsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetExportsRequest) Skip(skip int32) apiGetExportsRequest {
	r.skip = &skip
	return r
}

func (r apiGetExportsRequest) ApplicationId(applicationId int32) apiGetExportsRequest {
	r.applicationId = &applicationId
	return r
}

func (r apiGetExportsRequest) CampaignId(campaignId int32) apiGetExportsRequest {
	r.campaignId = &campaignId
	return r
}

func (r apiGetExportsRequest) Entity(entity string) apiGetExportsRequest {
	r.entity = &entity
	return r
}

/*
GetExports Get Exports
Get a list of all past exports

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetExportsRequest
*/
func (a *ManagementApiService) GetExports(ctx _context.Context) apiGetExportsRequest {
	return apiGetExportsRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20029
*/
func (r apiGetExportsRequest) Execute() (InlineResponse20029, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20029
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetExports")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/exports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.applicationId != nil {
		localVarQueryParams.Add("applicationId", parameterToString(*r.applicationId, ""))
	}
	if r.campaignId != nil {
		localVarQueryParams.Add("campaignId", parameterToString(*r.campaignId, ""))
	}
	if r.entity != nil {
		localVarQueryParams.Add("entity", parameterToString(*r.entity, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20029
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetLoyaltyPointsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	programID     string
	integrationID string
}

/*
GetLoyaltyPoints get the Loyalty Ledger for this integrationID
Get the Loyalty Ledger for this profile integration ID.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param programID The identifier for the application, must be unique within the account.
 * @param integrationID The identifier for the application, must be unique within the account.
@return apiGetLoyaltyPointsRequest
*/
func (a *ManagementApiService) GetLoyaltyPoints(ctx _context.Context, programID string, integrationID string) apiGetLoyaltyPointsRequest {
	return apiGetLoyaltyPointsRequest{
		apiService:    a,
		ctx:           ctx,
		programID:     programID,
		integrationID: integrationID,
	}
}

/*
Execute executes the request
 @return LoyaltyLedger
*/
func (r apiGetLoyaltyPointsRequest) Execute() (LoyaltyLedger, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LoyaltyLedger
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetLoyaltyPoints")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/loyalty_programs/{programID}/profile/{integrationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"programID"+"}", _neturl.QueryEscape(parameterToString(r.programID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationID"+"}", _neturl.QueryEscape(parameterToString(r.integrationID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LoyaltyLedger
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetLoyaltyProgramRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	programID  string
}

/*
GetLoyaltyProgram Get a loyalty program
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param programID
@return apiGetLoyaltyProgramRequest
*/
func (a *ManagementApiService) GetLoyaltyProgram(ctx _context.Context, programID string) apiGetLoyaltyProgramRequest {
	return apiGetLoyaltyProgramRequest{
		apiService: a,
		ctx:        ctx,
		programID:  programID,
	}
}

/*
Execute executes the request
 @return LoyaltyProgram
*/
func (r apiGetLoyaltyProgramRequest) Execute() (LoyaltyProgram, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LoyaltyProgram
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetLoyaltyProgram")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/loyalty_programs/{programID}"
	localVarPath = strings.Replace(localVarPath, "{"+"programID"+"}", _neturl.QueryEscape(parameterToString(r.programID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LoyaltyProgram
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetLoyaltyProgramsRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
}

/*
GetLoyaltyPrograms List all loyalty Programs
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetLoyaltyProgramsRequest
*/
func (a *ManagementApiService) GetLoyaltyPrograms(ctx _context.Context) apiGetLoyaltyProgramsRequest {
	return apiGetLoyaltyProgramsRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse2008
*/
func (r apiGetLoyaltyProgramsRequest) Execute() (InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2008
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetLoyaltyPrograms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/loyalty_programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2008
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetLoyaltyStatisticsRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	programID  string
}

/*
GetLoyaltyStatistics Get loyalty program statistics by loyalty program ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param programID
@return apiGetLoyaltyStatisticsRequest
*/
func (a *ManagementApiService) GetLoyaltyStatistics(ctx _context.Context, programID string) apiGetLoyaltyStatisticsRequest {
	return apiGetLoyaltyStatisticsRequest{
		apiService: a,
		ctx:        ctx,
		programID:  programID,
	}
}

/*
Execute executes the request
 @return LoyaltyStatistics
*/
func (r apiGetLoyaltyStatisticsRequest) Execute() (LoyaltyStatistics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  LoyaltyStatistics
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetLoyaltyStatistics")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/loyalty_programs/{programID}/statistics"
	localVarPath = strings.Replace(localVarPath, "{"+"programID"+"}", _neturl.QueryEscape(parameterToString(r.programID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v LoyaltyStatistics
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetReferralsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	pageSize      *int32
	skip          *int32
	sort          *string
	code          *string
	createdBefore *time.Time
	createdAfter  *time.Time
	valid         *string
	usable        *string
	advocate      *string
}

func (r apiGetReferralsRequest) PageSize(pageSize int32) apiGetReferralsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetReferralsRequest) Skip(skip int32) apiGetReferralsRequest {
	r.skip = &skip
	return r
}

func (r apiGetReferralsRequest) Sort(sort string) apiGetReferralsRequest {
	r.sort = &sort
	return r
}

func (r apiGetReferralsRequest) Code(code string) apiGetReferralsRequest {
	r.code = &code
	return r
}

func (r apiGetReferralsRequest) CreatedBefore(createdBefore time.Time) apiGetReferralsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetReferralsRequest) CreatedAfter(createdAfter time.Time) apiGetReferralsRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetReferralsRequest) Valid(valid string) apiGetReferralsRequest {
	r.valid = &valid
	return r
}

func (r apiGetReferralsRequest) Usable(usable string) apiGetReferralsRequest {
	r.usable = &usable
	return r
}

func (r apiGetReferralsRequest) Advocate(advocate string) apiGetReferralsRequest {
	r.advocate = &advocate
	return r
}

/*
GetReferrals List Referrals (with total count)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiGetReferralsRequest
*/
func (a *ManagementApiService) GetReferrals(ctx _context.Context, applicationId int32, campaignId int32) apiGetReferralsRequest {
	return apiGetReferralsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2006
*/
func (r apiGetReferralsRequest) Execute() (InlineResponse2006, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2006
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetReferrals")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/referrals"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.code != nil {
		localVarQueryParams.Add("code", parameterToString(*r.code, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.advocate != nil {
		localVarQueryParams.Add("advocate", parameterToString(*r.advocate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2006
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetReferralsWithoutTotalCountRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	pageSize      *int32
	skip          *int32
	sort          *string
	code          *string
	createdBefore *time.Time
	createdAfter  *time.Time
	valid         *string
	usable        *string
	advocate      *string
}

func (r apiGetReferralsWithoutTotalCountRequest) PageSize(pageSize int32) apiGetReferralsWithoutTotalCountRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetReferralsWithoutTotalCountRequest) Skip(skip int32) apiGetReferralsWithoutTotalCountRequest {
	r.skip = &skip
	return r
}

func (r apiGetReferralsWithoutTotalCountRequest) Sort(sort string) apiGetReferralsWithoutTotalCountRequest {
	r.sort = &sort
	return r
}

func (r apiGetReferralsWithoutTotalCountRequest) Code(code string) apiGetReferralsWithoutTotalCountRequest {
	r.code = &code
	return r
}

func (r apiGetReferralsWithoutTotalCountRequest) CreatedBefore(createdBefore time.Time) apiGetReferralsWithoutTotalCountRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetReferralsWithoutTotalCountRequest) CreatedAfter(createdAfter time.Time) apiGetReferralsWithoutTotalCountRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiGetReferralsWithoutTotalCountRequest) Valid(valid string) apiGetReferralsWithoutTotalCountRequest {
	r.valid = &valid
	return r
}

func (r apiGetReferralsWithoutTotalCountRequest) Usable(usable string) apiGetReferralsWithoutTotalCountRequest {
	r.usable = &usable
	return r
}

func (r apiGetReferralsWithoutTotalCountRequest) Advocate(advocate string) apiGetReferralsWithoutTotalCountRequest {
	r.advocate = &advocate
	return r
}

/*
GetReferralsWithoutTotalCount List Referrals
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiGetReferralsWithoutTotalCountRequest
*/
func (a *ManagementApiService) GetReferralsWithoutTotalCount(ctx _context.Context, applicationId int32, campaignId int32) apiGetReferralsWithoutTotalCountRequest {
	return apiGetReferralsWithoutTotalCountRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2007
*/
func (r apiGetReferralsWithoutTotalCountRequest) Execute() (InlineResponse2007, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2007
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetReferralsWithoutTotalCount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/no_total"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.code != nil {
		localVarQueryParams.Add("code", parameterToString(*r.code, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.advocate != nil {
		localVarQueryParams.Add("advocate", parameterToString(*r.advocate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2007
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetRoleRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	roleId     int32
}

/*
GetRole Get information for the specified role.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param roleId
@return apiGetRoleRequest
*/
func (a *ManagementApiService) GetRole(ctx _context.Context, roleId int32) apiGetRoleRequest {
	return apiGetRoleRequest{
		apiService: a,
		ctx:        ctx,
		roleId:     roleId,
	}
}

/*
Execute executes the request
 @return Role
*/
func (r apiGetRoleRequest) Execute() (Role, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Role
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetRole")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/roles/{roleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"roleId"+"}", _neturl.QueryEscape(parameterToString(r.roleId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Role
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetRulesetRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	rulesetId     int32
}

/*
GetRuleset Get a Ruleset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
 * @param rulesetId
@return apiGetRulesetRequest
*/
func (a *ManagementApiService) GetRuleset(ctx _context.Context, applicationId int32, campaignId int32, rulesetId int32) apiGetRulesetRequest {
	return apiGetRulesetRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
		rulesetId:     rulesetId,
	}
}

/*
Execute executes the request
 @return Ruleset
*/
func (r apiGetRulesetRequest) Execute() (Ruleset, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Ruleset
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetRuleset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rulesetId"+"}", _neturl.QueryEscape(parameterToString(r.rulesetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Ruleset
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetRulesetsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	pageSize      *int32
	skip          *int32
	sort          *string
}

func (r apiGetRulesetsRequest) PageSize(pageSize int32) apiGetRulesetsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetRulesetsRequest) Skip(skip int32) apiGetRulesetsRequest {
	r.skip = &skip
	return r
}

func (r apiGetRulesetsRequest) Sort(sort string) apiGetRulesetsRequest {
	r.sort = &sort
	return r
}

/*
GetRulesets List Campaign Rulesets
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiGetRulesetsRequest
*/
func (a *ManagementApiService) GetRulesets(ctx _context.Context, applicationId int32, campaignId int32) apiGetRulesetsRequest {
	return apiGetRulesetsRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2003
*/
func (r apiGetRulesetsRequest) Execute() (InlineResponse2003, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2003
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetRulesets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2003
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetUserRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	userId     int32
}

/*
GetUser Get a single User
Retrieves the data (including an invitation code) for a user. Non-admin users can only get themselves.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId
@return apiGetUserRequest
*/
func (a *ManagementApiService) GetUser(ctx _context.Context, userId int32) apiGetUserRequest {
	return apiGetUserRequest{
		apiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

/*
Execute executes the request
 @return User
*/
func (r apiGetUserRequest) Execute() (User, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  User
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetUser")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v User
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetUsersRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	pageSize   *int32
	skip       *int32
	sort       *string
}

func (r apiGetUsersRequest) PageSize(pageSize int32) apiGetUsersRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetUsersRequest) Skip(skip int32) apiGetUsersRequest {
	r.skip = &skip
	return r
}

func (r apiGetUsersRequest) Sort(sort string) apiGetUsersRequest {
	r.sort = &sort
	return r
}

/*
GetUsers List Users in your account
Retrieve all users in your account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetUsersRequest
*/
func (a *ManagementApiService) GetUsers(ctx _context.Context) apiGetUsersRequest {
	return apiGetUsersRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20027
*/
func (r apiGetUsersRequest) Execute() (InlineResponse20027, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20027
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetUsers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20027
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetWebhookRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	webhookId  int32
}

/*
GetWebhook Get Webhook
Returns an webhook by its id.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param webhookId
@return apiGetWebhookRequest
*/
func (a *ManagementApiService) GetWebhook(ctx _context.Context, webhookId int32) apiGetWebhookRequest {
	return apiGetWebhookRequest{
		apiService: a,
		ctx:        ctx,
		webhookId:  webhookId,
	}
}

/*
Execute executes the request
 @return Webhook
*/
func (r apiGetWebhookRequest) Execute() (Webhook, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Webhook
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetWebhook")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/webhooks/{webhookId}"
	localVarPath = strings.Replace(localVarPath, "{"+"webhookId"+"}", _neturl.QueryEscape(parameterToString(r.webhookId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Webhook
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetWebhookActivationLogsRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	pageSize               *int32
	skip                   *int32
	sort                   *string
	integrationRequestUuid *string
	webhookId              *float32
	applicationId          *float32
	campaignId             *float32
	createdBefore          *time.Time
	createdAfter           *time.Time
}

func (r apiGetWebhookActivationLogsRequest) PageSize(pageSize int32) apiGetWebhookActivationLogsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetWebhookActivationLogsRequest) Skip(skip int32) apiGetWebhookActivationLogsRequest {
	r.skip = &skip
	return r
}

func (r apiGetWebhookActivationLogsRequest) Sort(sort string) apiGetWebhookActivationLogsRequest {
	r.sort = &sort
	return r
}

func (r apiGetWebhookActivationLogsRequest) IntegrationRequestUuid(integrationRequestUuid string) apiGetWebhookActivationLogsRequest {
	r.integrationRequestUuid = &integrationRequestUuid
	return r
}

func (r apiGetWebhookActivationLogsRequest) WebhookId(webhookId float32) apiGetWebhookActivationLogsRequest {
	r.webhookId = &webhookId
	return r
}

func (r apiGetWebhookActivationLogsRequest) ApplicationId(applicationId float32) apiGetWebhookActivationLogsRequest {
	r.applicationId = &applicationId
	return r
}

func (r apiGetWebhookActivationLogsRequest) CampaignId(campaignId float32) apiGetWebhookActivationLogsRequest {
	r.campaignId = &campaignId
	return r
}

func (r apiGetWebhookActivationLogsRequest) CreatedBefore(createdBefore time.Time) apiGetWebhookActivationLogsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetWebhookActivationLogsRequest) CreatedAfter(createdAfter time.Time) apiGetWebhookActivationLogsRequest {
	r.createdAfter = &createdAfter
	return r
}

/*
GetWebhookActivationLogs List Webhook activation Log Entries
Webhook activation log entries would be created as soon as an integration request triggered an effect with a webhook
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetWebhookActivationLogsRequest
*/
func (a *ManagementApiService) GetWebhookActivationLogs(ctx _context.Context) apiGetWebhookActivationLogsRequest {
	return apiGetWebhookActivationLogsRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20024
*/
func (r apiGetWebhookActivationLogsRequest) Execute() (InlineResponse20024, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20024
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetWebhookActivationLogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/webhook_activation_logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.integrationRequestUuid != nil {
		localVarQueryParams.Add("integrationRequestUuid", parameterToString(*r.integrationRequestUuid, ""))
	}
	if r.webhookId != nil {
		localVarQueryParams.Add("webhookId", parameterToString(*r.webhookId, ""))
	}
	if r.applicationId != nil {
		localVarQueryParams.Add("applicationId", parameterToString(*r.applicationId, ""))
	}
	if r.campaignId != nil {
		localVarQueryParams.Add("campaignId", parameterToString(*r.campaignId, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20024
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetWebhookLogsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	pageSize      *int32
	skip          *int32
	sort          *string
	status        *string
	webhookId     *float32
	applicationId *float32
	campaignId    *float32
	requestUuid   *string
	createdBefore *time.Time
	createdAfter  *time.Time
}

func (r apiGetWebhookLogsRequest) PageSize(pageSize int32) apiGetWebhookLogsRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetWebhookLogsRequest) Skip(skip int32) apiGetWebhookLogsRequest {
	r.skip = &skip
	return r
}

func (r apiGetWebhookLogsRequest) Sort(sort string) apiGetWebhookLogsRequest {
	r.sort = &sort
	return r
}

func (r apiGetWebhookLogsRequest) Status(status string) apiGetWebhookLogsRequest {
	r.status = &status
	return r
}

func (r apiGetWebhookLogsRequest) WebhookId(webhookId float32) apiGetWebhookLogsRequest {
	r.webhookId = &webhookId
	return r
}

func (r apiGetWebhookLogsRequest) ApplicationId(applicationId float32) apiGetWebhookLogsRequest {
	r.applicationId = &applicationId
	return r
}

func (r apiGetWebhookLogsRequest) CampaignId(campaignId float32) apiGetWebhookLogsRequest {
	r.campaignId = &campaignId
	return r
}

func (r apiGetWebhookLogsRequest) RequestUuid(requestUuid string) apiGetWebhookLogsRequest {
	r.requestUuid = &requestUuid
	return r
}

func (r apiGetWebhookLogsRequest) CreatedBefore(createdBefore time.Time) apiGetWebhookLogsRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiGetWebhookLogsRequest) CreatedAfter(createdAfter time.Time) apiGetWebhookLogsRequest {
	r.createdAfter = &createdAfter
	return r
}

/*
GetWebhookLogs List Webhook Log Entries
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetWebhookLogsRequest
*/
func (a *ManagementApiService) GetWebhookLogs(ctx _context.Context) apiGetWebhookLogsRequest {
	return apiGetWebhookLogsRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20025
*/
func (r apiGetWebhookLogsRequest) Execute() (InlineResponse20025, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20025
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetWebhookLogs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/webhook_logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.webhookId != nil {
		localVarQueryParams.Add("webhookId", parameterToString(*r.webhookId, ""))
	}
	if r.applicationId != nil {
		localVarQueryParams.Add("applicationId", parameterToString(*r.applicationId, ""))
	}
	if r.campaignId != nil {
		localVarQueryParams.Add("campaignId", parameterToString(*r.campaignId, ""))
	}
	if r.requestUuid != nil {
		localVarQueryParams.Add("requestUuid", parameterToString(*r.requestUuid, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20025
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiGetWebhooksRequest struct {
	ctx            _context.Context
	apiService     *ManagementApiService
	applicationIds *string
	sort           *string
	pageSize       *int32
	skip           *int32
}

func (r apiGetWebhooksRequest) ApplicationIds(applicationIds string) apiGetWebhooksRequest {
	r.applicationIds = &applicationIds
	return r
}

func (r apiGetWebhooksRequest) Sort(sort string) apiGetWebhooksRequest {
	r.sort = &sort
	return r
}

func (r apiGetWebhooksRequest) PageSize(pageSize int32) apiGetWebhooksRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiGetWebhooksRequest) Skip(skip int32) apiGetWebhooksRequest {
	r.skip = &skip
	return r
}

/*
GetWebhooks List Webhooks
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiGetWebhooksRequest
*/
func (a *ManagementApiService) GetWebhooks(ctx _context.Context) apiGetWebhooksRequest {
	return apiGetWebhooksRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return InlineResponse20023
*/
func (r apiGetWebhooksRequest) Execute() (InlineResponse20023, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20023
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.GetWebhooks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/webhooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.applicationIds != nil {
		localVarQueryParams.Add("applicationIds", parameterToString(*r.applicationIds, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse20023
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiRemoveLoyaltyPointsRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	programID     string
	integrationID string
	body          *LoyaltyPoints
}

func (r apiRemoveLoyaltyPointsRequest) Body(body LoyaltyPoints) apiRemoveLoyaltyPointsRequest {
	r.body = &body
	return r
}

/*
RemoveLoyaltyPoints Deduct points in a certain loyalty program for the specified customer
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param programID
 * @param integrationID
@return apiRemoveLoyaltyPointsRequest
*/
func (a *ManagementApiService) RemoveLoyaltyPoints(ctx _context.Context, programID string, integrationID string) apiRemoveLoyaltyPointsRequest {
	return apiRemoveLoyaltyPointsRequest{
		apiService:    a,
		ctx:           ctx,
		programID:     programID,
		integrationID: integrationID,
	}
}

/*
Execute executes the request

*/
func (r apiRemoveLoyaltyPointsRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.RemoveLoyaltyPoints")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/loyalty_programs/{programID}/profile/{integrationID}/deduct_points"
	localVarPath = strings.Replace(localVarPath, "{"+"programID"+"}", _neturl.QueryEscape(parameterToString(r.programID, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"integrationID"+"}", _neturl.QueryEscape(parameterToString(r.integrationID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiResetPasswordRequest struct {
	ctx        _context.Context
	apiService *ManagementApiService
	body       *NewPassword
}

func (r apiResetPasswordRequest) Body(body NewPassword) apiResetPasswordRequest {
	r.body = &body
	return r
}

/*
ResetPassword Reset password
Consumes the supplied password reset token and updates the password for
the associated account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return apiResetPasswordRequest
*/
func (a *ManagementApiService) ResetPassword(ctx _context.Context) apiResetPasswordRequest {
	return apiResetPasswordRequest{
		apiService: a,
		ctx:        ctx,
	}
}

/*
Execute executes the request
 @return NewPassword
*/
func (r apiResetPasswordRequest) Execute() (NewPassword, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NewPassword
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.ResetPassword")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/reset_password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 204 {
			var v NewPassword
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiSearchCouponsAdvancedRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	campaignId             int32
	body                   *map[string]interface{}
	pageSize               *int32
	skip                   *int32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	valid                  *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	exactMatch             *bool
	batchId                *string
}

func (r apiSearchCouponsAdvancedRequest) Body(body map[string]interface{}) apiSearchCouponsAdvancedRequest {
	r.body = &body
	return r
}

func (r apiSearchCouponsAdvancedRequest) PageSize(pageSize int32) apiSearchCouponsAdvancedRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiSearchCouponsAdvancedRequest) Skip(skip int32) apiSearchCouponsAdvancedRequest {
	r.skip = &skip
	return r
}

func (r apiSearchCouponsAdvancedRequest) Sort(sort string) apiSearchCouponsAdvancedRequest {
	r.sort = &sort
	return r
}

func (r apiSearchCouponsAdvancedRequest) Value(value string) apiSearchCouponsAdvancedRequest {
	r.value = &value
	return r
}

func (r apiSearchCouponsAdvancedRequest) CreatedBefore(createdBefore time.Time) apiSearchCouponsAdvancedRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiSearchCouponsAdvancedRequest) CreatedAfter(createdAfter time.Time) apiSearchCouponsAdvancedRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiSearchCouponsAdvancedRequest) Valid(valid string) apiSearchCouponsAdvancedRequest {
	r.valid = &valid
	return r
}

func (r apiSearchCouponsAdvancedRequest) Usable(usable string) apiSearchCouponsAdvancedRequest {
	r.usable = &usable
	return r
}

func (r apiSearchCouponsAdvancedRequest) ReferralId(referralId int32) apiSearchCouponsAdvancedRequest {
	r.referralId = &referralId
	return r
}

func (r apiSearchCouponsAdvancedRequest) RecipientIntegrationId(recipientIntegrationId string) apiSearchCouponsAdvancedRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiSearchCouponsAdvancedRequest) ExactMatch(exactMatch bool) apiSearchCouponsAdvancedRequest {
	r.exactMatch = &exactMatch
	return r
}

func (r apiSearchCouponsAdvancedRequest) BatchId(batchId string) apiSearchCouponsAdvancedRequest {
	r.batchId = &batchId
	return r
}

/*
SearchCouponsAdvanced Get a list of the coupons that match the given attributes (with total count)
Gets a list of all the coupons with attributes matching the query criteria

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiSearchCouponsAdvancedRequest
*/
func (a *ManagementApiService) SearchCouponsAdvanced(ctx _context.Context, applicationId int32, campaignId int32) apiSearchCouponsAdvancedRequest {
	return apiSearchCouponsAdvancedRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2004
*/
func (r apiSearchCouponsAdvancedRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.SearchCouponsAdvanced")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2004
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiSearchCouponsAdvancedApplicationWideRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	body                   *map[string]interface{}
	pageSize               *int32
	skip                   *int32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	valid                  *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	batchId                *string
	exactMatch             *bool
	campaignState          *string
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) Body(body map[string]interface{}) apiSearchCouponsAdvancedApplicationWideRequest {
	r.body = &body
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) PageSize(pageSize int32) apiSearchCouponsAdvancedApplicationWideRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) Skip(skip int32) apiSearchCouponsAdvancedApplicationWideRequest {
	r.skip = &skip
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) Sort(sort string) apiSearchCouponsAdvancedApplicationWideRequest {
	r.sort = &sort
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) Value(value string) apiSearchCouponsAdvancedApplicationWideRequest {
	r.value = &value
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) CreatedBefore(createdBefore time.Time) apiSearchCouponsAdvancedApplicationWideRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) CreatedAfter(createdAfter time.Time) apiSearchCouponsAdvancedApplicationWideRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) Valid(valid string) apiSearchCouponsAdvancedApplicationWideRequest {
	r.valid = &valid
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) Usable(usable string) apiSearchCouponsAdvancedApplicationWideRequest {
	r.usable = &usable
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) ReferralId(referralId int32) apiSearchCouponsAdvancedApplicationWideRequest {
	r.referralId = &referralId
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) RecipientIntegrationId(recipientIntegrationId string) apiSearchCouponsAdvancedApplicationWideRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) BatchId(batchId string) apiSearchCouponsAdvancedApplicationWideRequest {
	r.batchId = &batchId
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) ExactMatch(exactMatch bool) apiSearchCouponsAdvancedApplicationWideRequest {
	r.exactMatch = &exactMatch
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideRequest) CampaignState(campaignState string) apiSearchCouponsAdvancedApplicationWideRequest {
	r.campaignState = &campaignState
	return r
}

/*
SearchCouponsAdvancedApplicationWide Get a list of the coupons that match the given attributes in all active campaigns of an application (with total count)
Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiSearchCouponsAdvancedApplicationWideRequest
*/
func (a *ManagementApiService) SearchCouponsAdvancedApplicationWide(ctx _context.Context, applicationId int32) apiSearchCouponsAdvancedApplicationWideRequest {
	return apiSearchCouponsAdvancedApplicationWideRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse2004
*/
func (r apiSearchCouponsAdvancedApplicationWideRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.SearchCouponsAdvancedApplicationWide")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/coupons_search_advanced"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	if r.campaignState != nil {
		localVarQueryParams.Add("campaignState", parameterToString(*r.campaignState, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2004
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	body                   *map[string]interface{}
	pageSize               *int32
	skip                   *int32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	valid                  *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	batchId                *string
	exactMatch             *bool
	campaignState          *string
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) Body(body map[string]interface{}) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.body = &body
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) PageSize(pageSize int32) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) Skip(skip int32) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.skip = &skip
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) Sort(sort string) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.sort = &sort
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) Value(value string) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.value = &value
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) CreatedBefore(createdBefore time.Time) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) CreatedAfter(createdAfter time.Time) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) Valid(valid string) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.valid = &valid
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) Usable(usable string) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.usable = &usable
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) ReferralId(referralId int32) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.referralId = &referralId
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) RecipientIntegrationId(recipientIntegrationId string) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) BatchId(batchId string) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.batchId = &batchId
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) ExactMatch(exactMatch bool) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.exactMatch = &exactMatch
	return r
}

func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) CampaignState(campaignState string) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	r.campaignState = &campaignState
	return r
}

/*
SearchCouponsAdvancedApplicationWideWithoutTotalCount Get a list of the coupons that match the given attributes in all active campaigns of an application
Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
@return apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest
*/
func (a *ManagementApiService) SearchCouponsAdvancedApplicationWideWithoutTotalCount(ctx _context.Context, applicationId int32) apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest {
	return apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
	}
}

/*
Execute executes the request
 @return InlineResponse2005
*/
func (r apiSearchCouponsAdvancedApplicationWideWithoutTotalCountRequest) Execute() (InlineResponse2005, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2005
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.SearchCouponsAdvancedApplicationWideWithoutTotalCount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/coupons_search_advanced/no_total"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	if r.campaignState != nil {
		localVarQueryParams.Add("campaignState", parameterToString(*r.campaignState, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiSearchCouponsAdvancedWithoutTotalCountRequest struct {
	ctx                    _context.Context
	apiService             *ManagementApiService
	applicationId          int32
	campaignId             int32
	body                   *map[string]interface{}
	pageSize               *int32
	skip                   *int32
	sort                   *string
	value                  *string
	createdBefore          *time.Time
	createdAfter           *time.Time
	valid                  *string
	usable                 *string
	referralId             *int32
	recipientIntegrationId *string
	exactMatch             *bool
	batchId                *string
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) Body(body map[string]interface{}) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.body = &body
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) PageSize(pageSize int32) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.pageSize = &pageSize
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) Skip(skip int32) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.skip = &skip
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) Sort(sort string) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.sort = &sort
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) Value(value string) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.value = &value
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) CreatedBefore(createdBefore time.Time) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.createdBefore = &createdBefore
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) CreatedAfter(createdAfter time.Time) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.createdAfter = &createdAfter
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) Valid(valid string) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.valid = &valid
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) Usable(usable string) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.usable = &usable
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) ReferralId(referralId int32) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.referralId = &referralId
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) RecipientIntegrationId(recipientIntegrationId string) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.recipientIntegrationId = &recipientIntegrationId
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) ExactMatch(exactMatch bool) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.exactMatch = &exactMatch
	return r
}

func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) BatchId(batchId string) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	r.batchId = &batchId
	return r
}

/*
SearchCouponsAdvancedWithoutTotalCount Get a list of the coupons that match the given attributes
Gets a list of all the coupons with attributes matching the query criteria

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiSearchCouponsAdvancedWithoutTotalCountRequest
*/
func (a *ManagementApiService) SearchCouponsAdvancedWithoutTotalCount(ctx _context.Context, applicationId int32, campaignId int32) apiSearchCouponsAdvancedWithoutTotalCountRequest {
	return apiSearchCouponsAdvancedWithoutTotalCountRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return InlineResponse2005
*/
func (r apiSearchCouponsAdvancedWithoutTotalCountRequest) Execute() (InlineResponse2005, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2005
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.SearchCouponsAdvancedWithoutTotalCount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced/no_total"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.skip != nil {
		localVarQueryParams.Add("skip", parameterToString(*r.skip, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.value != nil {
		localVarQueryParams.Add("value", parameterToString(*r.value, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("createdBefore", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("createdAfter", parameterToString(*r.createdAfter, ""))
	}
	if r.valid != nil {
		localVarQueryParams.Add("valid", parameterToString(*r.valid, ""))
	}
	if r.usable != nil {
		localVarQueryParams.Add("usable", parameterToString(*r.usable, ""))
	}
	if r.referralId != nil {
		localVarQueryParams.Add("referralId", parameterToString(*r.referralId, ""))
	}
	if r.recipientIntegrationId != nil {
		localVarQueryParams.Add("recipientIntegrationId", parameterToString(*r.recipientIntegrationId, ""))
	}
	if r.exactMatch != nil {
		localVarQueryParams.Add("exactMatch", parameterToString(*r.exactMatch, ""))
	}
	if r.batchId != nil {
		localVarQueryParams.Add("batchId", parameterToString(*r.batchId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v InlineResponse2005
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiUpdateAdditionalCostRequest struct {
	ctx              _context.Context
	apiService       *ManagementApiService
	additionalCostId int32
	body             *NewAdditionalCost
}

func (r apiUpdateAdditionalCostRequest) Body(body NewAdditionalCost) apiUpdateAdditionalCostRequest {
	r.body = &body
	return r
}

/*
UpdateAdditionalCost Update an additional cost
Updates an existing additional cost. Once created, the only property of an additional cost that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param additionalCostId
@return apiUpdateAdditionalCostRequest
*/
func (a *ManagementApiService) UpdateAdditionalCost(ctx _context.Context, additionalCostId int32) apiUpdateAdditionalCostRequest {
	return apiUpdateAdditionalCostRequest{
		apiService:       a,
		ctx:              ctx,
		additionalCostId: additionalCostId,
	}
}

/*
Execute executes the request
 @return AccountAdditionalCost
*/
func (r apiUpdateAdditionalCostRequest) Execute() (AccountAdditionalCost, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountAdditionalCost
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.UpdateAdditionalCost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/additional_costs/{additionalCostId}"
	localVarPath = strings.Replace(localVarPath, "{"+"additionalCostId"+"}", _neturl.QueryEscape(parameterToString(r.additionalCostId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v AccountAdditionalCost
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiUpdateAttributeRequest struct {
	ctx         _context.Context
	apiService  *ManagementApiService
	attributeId int32
	body        *NewAttribute
}

func (r apiUpdateAttributeRequest) Body(body NewAttribute) apiUpdateAttributeRequest {
	r.body = &body
	return r
}

/*
UpdateAttribute Update a custom attribute
Updates an existing custom attribute. Once created, the only property of a custom attribute that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations. E.g. if you have a customer profile attribute with the name `region`, and your integration is sending `attributes.region` with customer profile updates, changing the name to `locale` would cause the integration requests to begin failing.

If you **really** need to change the `type` or `name` property of a custom attribute, create a new attribute and update any relevant integrations and rules to use the new attribute. Then delete the old attribute when you are confident you have migrated any needed data from the old attribute to the new one.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param attributeId
@return apiUpdateAttributeRequest
*/
func (a *ManagementApiService) UpdateAttribute(ctx _context.Context, attributeId int32) apiUpdateAttributeRequest {
	return apiUpdateAttributeRequest{
		apiService:  a,
		ctx:         ctx,
		attributeId: attributeId,
	}
}

/*
Execute executes the request
 @return Attribute
*/
func (r apiUpdateAttributeRequest) Execute() (Attribute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Attribute
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.UpdateAttribute")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/attributes/{attributeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.QueryEscape(parameterToString(r.attributeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Attribute
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiUpdateCampaignRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	body          *UpdateCampaign
}

func (r apiUpdateCampaignRequest) Body(body UpdateCampaign) apiUpdateCampaignRequest {
	r.body = &body
	return r
}

/*
UpdateCampaign Update a Campaign
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiUpdateCampaignRequest
*/
func (a *ManagementApiService) UpdateCampaign(ctx _context.Context, applicationId int32, campaignId int32) apiUpdateCampaignRequest {
	return apiUpdateCampaignRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request
 @return Campaign
*/
func (r apiUpdateCampaignRequest) Execute() (Campaign, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Campaign
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.UpdateCampaign")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Campaign
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiUpdateCouponRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	couponId      string
	body          *UpdateCoupon
}

func (r apiUpdateCouponRequest) Body(body UpdateCoupon) apiUpdateCouponRequest {
	r.body = &body
	return r
}

/*
UpdateCoupon Update a Coupon
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
 * @param couponId The ID of the coupon code to update
@return apiUpdateCouponRequest
*/
func (a *ManagementApiService) UpdateCoupon(ctx _context.Context, applicationId int32, campaignId int32, couponId string) apiUpdateCouponRequest {
	return apiUpdateCouponRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
		couponId:      couponId,
	}
}

/*
Execute executes the request
 @return Coupon
*/
func (r apiUpdateCouponRequest) Execute() (Coupon, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Coupon
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.UpdateCoupon")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"couponId"+"}", _neturl.QueryEscape(parameterToString(r.couponId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Coupon
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type apiUpdateCouponBatchRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	body          *UpdateCouponBatch
}

func (r apiUpdateCouponBatchRequest) Body(body UpdateCouponBatch) apiUpdateCouponBatchRequest {
	r.body = &body
	return r
}

/*
UpdateCouponBatch Update a Batch of Coupons
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
@return apiUpdateCouponBatchRequest
*/
func (a *ManagementApiService) UpdateCouponBatch(ctx _context.Context, applicationId int32, campaignId int32) apiUpdateCouponBatchRequest {
	return apiUpdateCouponBatchRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
	}
}

/*
Execute executes the request

*/
func (r apiUpdateCouponBatchRequest) Execute() (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.UpdateCouponBatch")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/coupons"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type apiUpdateRulesetRequest struct {
	ctx           _context.Context
	apiService    *ManagementApiService
	applicationId int32
	campaignId    int32
	rulesetId     int32
	body          *NewRuleset
}

func (r apiUpdateRulesetRequest) Body(body NewRuleset) apiUpdateRulesetRequest {
	r.body = &body
	return r
}

/*
UpdateRuleset Update a Ruleset
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param applicationId
 * @param campaignId
 * @param rulesetId
@return apiUpdateRulesetRequest
*/
func (a *ManagementApiService) UpdateRuleset(ctx _context.Context, applicationId int32, campaignId int32, rulesetId int32) apiUpdateRulesetRequest {
	return apiUpdateRulesetRequest{
		apiService:    a,
		ctx:           ctx,
		applicationId: applicationId,
		campaignId:    campaignId,
		rulesetId:     rulesetId,
	}
}

/*
Execute executes the request
 @return Ruleset
*/
func (r apiUpdateRulesetRequest) Execute() (Ruleset, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Ruleset
	)

	localBasePath, err := r.apiService.client.cfg.ServerURLWithContext(r.ctx, "ManagementApiService.UpdateRuleset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"applicationId"+"}", _neturl.QueryEscape(parameterToString(r.applicationId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"campaignId"+"}", _neturl.QueryEscape(parameterToString(r.campaignId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rulesetId"+"}", _neturl.QueryEscape(parameterToString(r.rulesetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if auth, ok := auth["Authorization"]; ok {
				var key string
				if auth.Prefix != "" {
					key = auth.Prefix + " " + auth.Key
				} else {
					key = auth.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := r.apiService.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := r.apiService.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 200 {
			var v Ruleset
			err = r.apiService.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = r.apiService.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
